{"componentChunkName":"component---src-templates-post-jsx","path":"/jvm-under-the-hood/","result":{"data":{"site":{"siteMetadata":{"title":"onseok.blog"}},"markdownRemark":{"id":"d2ebdb60-2bb2-53a8-82d4-5766746f2c97","excerpt":"안드로이드 개발자라면 Dalvik, ART에 대해서 많이 들어봤을 것입니다. Dalvik은 초기 안드로이드에서 사용된 가상 머신으로, 메모리와 배터리 제약을 극복하기 위해 스택 기반 대신 레지스터 기반 바이트코드를 사용하여 효율적으로 동작하도록 설계되었습니다. 이후 Android 5.0부터는 가 기본 런타임 환경으로 전환되었는데, ART는 설치 시 를 통…","html":"<p>안드로이드 개발자라면 <strong>Dalvik, ART</strong>에 대해서 많이 들어봤을 것입니다. <a href=\"https://en.wikipedia.org/wiki/Dalvik_(software)\">Dalvik</a>은 초기 안드로이드에서 사용된 가상 머신으로, 메모리와 배터리 제약을 극복하기 위해 스택 기반 대신 레지스터 기반 바이트코드를 사용하여 효율적으로 동작하도록 설계되었습니다. 이후 Android 5.0부터는 <code class=\"language-text\">ART(Android Runtime)</code>가 기본 런타임 환경으로 전환되었는데, ART는 설치 시 <code class=\"language-text\">AOT(Ahead-Of-Time)</code>를 통해 앱을 네이티브 코드로 변환하고, 필요에 따라 <code class=\"language-text\">JIT(Just-In-Time)</code>를 추가로 적용하여 실행 성능을 크게 향상시킵니다.</p>\n<p>마침 회사 백엔드 개발자분들께서도 JVM에 관심이 생겨 사내에서 함께 공부해 보자는 제안을 해주셨고, 평소 더 파보고 싶었던 JVM의 <code class=\"language-text\">GC</code>, <code class=\"language-text\">메모리 관리 기법</code> 등의 개념을 공부하면 Android 런타임 환경의 내부 동작 방식을 이해하는 데에 도움이 될 수 있을 것이라고 생각하여 설레는 마음으로 스터디에 합류하게 되었습니다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/656bfeb5df717247362c11dccea65026/cae0a/jvm-under-the-hood.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 133.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,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'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='책이 생각보다 훨씬 두꺼워서 놀랐었다...' title='' src='/static/656bfeb5df717247362c11dccea65026/ca1dc/jvm-under-the-hood.png' srcset='/static/656bfeb5df717247362c11dccea65026/e7570/jvm-under-the-hood.png 170w,\n/static/656bfeb5df717247362c11dccea65026/f46e7/jvm-under-the-hood.png 340w,\n/static/656bfeb5df717247362c11dccea65026/ca1dc/jvm-under-the-hood.png 680w,\n/static/656bfeb5df717247362c11dccea65026/02d09/jvm-under-the-hood.png 1020w,\n/static/656bfeb5df717247362c11dccea65026/9d567/jvm-under-the-hood.png 1360w,\n/static/656bfeb5df717247362c11dccea65026/cae0a/jvm-under-the-hood.png 3024w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>책이 생각보다 훨씬 두꺼워서 놀랐었다...</figcaption>\n  </figure></p>\n<p>스터디 교재로는 <a href=\"https://www.yes24.com/Product/Goods/126114513\">『JVM 밑바닥까지 파헤치기』</a>라는 책을 선택했습니다. 책의 분량이 많았기 때문에 챕터별로 담당자를 지정해서 읽어오고, 이를 사내 컨플루언스에 문서화하고 발표하는 방식의 스터디를 진행하였습니다. 발표를 하면서도 짧은 질문과 의견들이 오고갔고, 주로 <code class=\"language-text\">이 부분에서 자신이 이해한 것이 맞는지?</code>를 중심으로 근거를 찾아가면서 스터디를 진행하였습니다.</p>\n<blockquote>\n<p>여러 챕터에 걸쳐서 안드로이드 개발자에게 좋은 내용들이 많았지만, 개인적으로는 가비지 컬렉터의 내용이 가장 좋았기 때문에 '3장 가비지 컬렉터와 메모리 할당 전략'의 핵심 내용들을 요약해서 정리해보도록 하겠습니다.</p>\n</blockquote>\n<h3 id=\"가비지-컬렉션\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\" aria-label=\"가비지 컬렉션 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가비지 컬렉션?</h3>\n<p>가비지 컬렉션(GC)은 자바 언어에서 처음 소개한 기술이 아니며, MIT에서 개발된 리스프라는 언어가 시초라고 합니다. 이러한 가비지 컬렉션과 메모리 할당의 내부 동작을 이해하면 다양한 메모리 오버플로우, 메모리 누수 문제를 해결해야하는 상황에 도움이 될 수 있습니다. </p>\n<h3 id=\"자바-힙과-메서드-영역은-불확실\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94-%ED%9E%99%EA%B3%BC-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD%EC%9D%80-%EB%B6%88%ED%99%95%EC%8B%A4\" aria-label=\"자바 힙과 메서드 영역은 불확실 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>자바 힙과 메서드 영역은 불확실</h3>\n<p>구현한 클래스마다 요구하는 메모리 크기가 다를 수 있습니다. 프로그램이 어떤 객체를 생성할지, 얼마나 많이 만들지는 오직 런타임에만 알 수 있습니다. 그래서 이 메모리 영역들의 회수는 동적으로 이루어지고, 가비지 컬렉터는 이런 영역을 관리하는 데 집중합니다.</p>\n<p>가비지 컬렉터가 <strong>힙을 청소</strong>하려면 어떤 객체가 살아 있고 죽었는지를 판단해야 하는데, 여기서 죽었다는 말은 어떤 식으로도 프로그램 코드에서 사용될 수 없다는 뜻입니다.</p>\n<p>여기서 객체가 살아있는지 판단하는 알고리즘으로 크게 두 가지로 나눌 수 있습니다.</p>\n<ul>\n<li>참조 카운팅 알고리즘</li>\n<li>도달 가능성 분석 알고리즘</li>\n</ul>\n<h3 id=\"참조-카운팅-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0-%EC%B9%B4%EC%9A%B4%ED%8C%85-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"참조 카운팅 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>참조 카운팅 알고리즘</h3>\n<ol>\n<li>객체를 가리키는 참조 카운터를 추가. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가</li>\n<li>참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소</li>\n<li>카운터 값이 0이 된 객체는 더는 사용될 수 없음</li>\n</ol>\n<blockquote>\n<p>마이크로소프트 COM, 파이썬, 러스트 등이 메모리 관리에 참조 카운팅 알고리즘 사용한다고 합니다.</p>\n</blockquote>\n<p>그런데 자바, 적어도 자바 가상 머신에서는 참조 카운팅을 사용하지 않는데, 그 이유는 바로 <code class=\"language-text\">순환 참조 문제</code>를 풀기 어렵기 때문입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReferenceCountingGC</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testGC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 두 객체 생성</span>\n    <span class=\"token class-name\">ReferenceCountingGC</span> objA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceCountingGC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">ReferenceCountingGC</span> objB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceCountingGC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 내부 필드로 서로를 참조</span>\n    objA<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> objB<span class=\"token punctuation\">;</span>\n    objB<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> objA<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 참조 해제</span>\n    objA <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    objB <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 이 라인에서 GC가 수행된다면 objA와 objB가 회수될까?</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">testGC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>참조를 해제한 시점부터 두 객체에 접근할 길이 사라지지만, 아직도 서로를 참조하고 있기 때문에 참조 카운터는 아직 0이 아닙니다. 따라서 참조 카운팅 알고리즘으로는 둘을 회수하지 못하게 됩니다.</p>\n<p>그러나 실행 결과 자바 가상머신에서 <code class=\"language-text\">objA</code>와 <code class=\"language-text\">objB</code>가 메모리에서 회수되었음을 확인할 수 있고, 이는 자바 가상 머신은 객체 생사 판단에 <code class=\"language-text\">참조 카운팅 알고리즘</code>을 사용하지 않는다는 것을 알 수 있습니다.</p>\n<h3 id=\"도달-가능성-분석-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EB%8B%AC-%EA%B0%80%EB%8A%A5%EC%84%B1-%EB%B6%84%EC%84%9D-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"도달 가능성 분석 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>도달 가능성 분석 알고리즘</h3>\n<p>자바, C# 등의 주류 언어들은 객체 생사 판단에 도달 가능성 분석(reachability analysis) 알고리즘을 사용합니다. 이 알고리즘의 핵심은 <code class=\"language-text\">GC 루트</code> 입니다. 이 루트 객체들을 시작 노드 집합으로 사용하며, 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색하여 들어가는 흐름으로 진행됩니다. 이때 탐색 과정에서 만들어지는 경로를 <code class=\"language-text\">참조 체인(reference chain)</code>이라고 부릅니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/9a1af47920a6b104f08e08dc3a35d54f/18d28/gc-root.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 59.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACr0lEQVR42lVSaU9aURR8/7Fp0mjSpF/qUlRoEZTCk0Xgsa/KooCAgrLKJou40rjVmtq0Tf/NdN6lbdIPk7nv3HvnzJl3pYfWNibVCG7qMSKO+1YCnzspPHbT+DrM4nmUw7fTvSkT38d5/CB+nhX+8V/8Oi9CGu0pqEZNaKXs2LZqYNPMwKt/g1pcxqjowSDvxrDgJit/1orAeN+LcWGKs30f4cUTjUj9rBNHERMa2zL2/Qak7Bpk3Fo0kzJOsg70Mg50ic6Ofcq7f3jHht6uA62EFYehNZQDBtw34pBuamFMKn5cVwI4O1DQzzkE3zRCuGuFGUEE9+0IHtpRgdtmGJ+qwf8wOQrg6tCHx5YqWA9RMIC7ZgSHESNc2lnE5TmclxQ89baYZ4x5xvGF68fuFOqdk10rro98eOL3cz+B55ME1xS8LHlxVfaKzR7HqcZNqMZMuCh76CYknE+qAe6rHBRi46KCUd7J3NxiultOc8v6XSMMaVxwohZbRymoR3PbzAM+nLJWDhmE4w6dXJQ8IobBnpNNbegzW3XEiwMP+hk7VI1Lnpkc+SF1UjKcyzOwzL1A2r6IU3YWtZUZyPMvsevUiAbDPQcaWx/5A43o7liFQzXv44SFhkwY5jbZQIHUS8uox9ZQjazhmA57PNxlrbG1zudk4GUZg5wNg6yNuW2I7PoZKwXsZBtG5JH6I9n0Yt8FqZ00o5Mwoy1g4TMwU9wIv/41XHSZocNO2iJcd9Mb5A2ObEfB+x5J2yIKHh3yihaVMONJWiBVwqsoBfQoB1cF1JGKXh0U3Swcy6+QtM5zJCMqrNc4SS26RvcmcVYVyrlXkHUuIbupQdmvh1RkB1Ug79ESOgosMst3SBIpZpq0LSBB0bjlLXmB9el+YmMeWdcS6lEjJzLQoYGP+wN+A5L4oxFzluFCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='gc root' title='' src='/static/9a1af47920a6b104f08e08dc3a35d54f/ca1dc/gc-root.png' srcset='/static/9a1af47920a6b104f08e08dc3a35d54f/e7570/gc-root.png 170w,\n/static/9a1af47920a6b104f08e08dc3a35d54f/f46e7/gc-root.png 340w,\n/static/9a1af47920a6b104f08e08dc3a35d54f/ca1dc/gc-root.png 680w,\n/static/9a1af47920a6b104f08e08dc3a35d54f/02d09/gc-root.png 1020w,\n/static/9a1af47920a6b104f08e08dc3a35d54f/9d567/gc-root.png 1360w,\n/static/9a1af47920a6b104f08e08dc3a35d54f/18d28/gc-root.png 1444w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>단, 자바에서 GC 루트로 이용할 수 있는 객체는 정해져 있는데, 그 종류는 다음과 같습니다.</p>\n<ul>\n<li><code class=\"language-text\">가상 머신 스택(스택 프레임의 지역 변수 테이블)에서 참조하는 객체</code> : 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등</li>\n<li><code class=\"language-text\">메서드 영역에서 클래스가 정적 필드로 참조하는 객체</code> : 자바 클래스의 참조 타입 정적 변수</li>\n<li><code class=\"language-text\">메서드 영역에서 상수로 참조되는 객체</code> : 문자열 테이블 안의 참조</li>\n<li><code class=\"language-text\">네이티브 메서드 스택에서 JNI가 참조하는 객체</code></li>\n<li><code class=\"language-text\">자바 가상 머신 내부에서 쓰이는 참조</code> : 기본 데이터 타입에 해당하는 Class 객체, 시스템 클래스 로더 등</li>\n<li><code class=\"language-text\">동기화 락(synchronized 키워드)으로 잠겨 있는 모든 객체</code></li>\n<li><code class=\"language-text\">자바 가상 머신 내부 상황을 반영하는 JMXBean</code> : JVMTI에 등록된 콜백, 로컬 코드 캐시 등</li>\n</ul>\n<p>이외에도 가비지 컬렉터의 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 <code class=\"language-text\">임시로</code> 추가가 가능합니다.</p>\n<h3 id=\"세대-단위-컬렉션-이론\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%8C%80-%EB%8B%A8%EC%9C%84-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%9D%B4%EB%A1%A0\" aria-label=\"세대 단위 컬렉션 이론 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>세대 단위 컬렉션 이론</h3>\n<p>현재 상용 가상 머신들이 채택한 가비지 컬렉터들은 대부분 세대 단위 컬렉션 이론에 기초해 설계되었습니다.</p>\n<p><span style=\"color:orange\">1. 약한 세대 가설 : 대다수 객체는 일찍 죽는다.</span></p>\n<p><span style=\"color:orange\">2. 강한 세대 가설 : 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.</span></p>\n<blockquote>\n<p>💬 “늙었다는 것은 살아남았다는 것”</p>\n</blockquote>\n<p>이 두 가지 가정이 합쳐져 가비지 컬렉터들에 일관된 설계 원칙을 제공합니다.\n여기서 <code class=\"language-text\">나이 = 가비지 컬렉션에서 살아남은 횟수</code>이고, <strong>대부분의 객체가 곧바로 죽을 운명이라면?</strong> 살아남는 소수의 객체를 유지하는 방법에 집중하는 편이 유리합니다.\n한 번 살아남은 객체는 통계적으로 잘 죽지 않으니 다른 영역에 따로 모아 두고, 가상 머신이 그 영역을 회수하는 빈도를 줄이는 방식입니다.</p>\n<p>이러한 세대 단위 컬렉션 이론을 가상 머신에 적용한 설계자들은 <strong>자바 힙</strong>을 최소 두개의 영역으로 나누게 되었습니다.</p>\n<ol>\n<li>신세대 : 가비지 컬렉션 때마다 다수의 객체가 죽고 살아남은 소수만 구세대로 승격</li>\n<li>구세대 </li>\n</ol>\n<p>그러나 복잡해 보이는 상황이 하나가 있습니다. 🤔</p>\n<ul>\n<li>객체들은 단독으로 존재 X</li>\n<li>다른 세대에 존재하는 객체들을 참조하는 상황이 있음</li>\n</ul>\n<p>또한, 신세대에서만 가비지 컬렉션을 하고 싶어도 구세대에서 참조 중인 객체도 분명 있을 것입니다. 살아남을 객체를 찾으려면 고정된 <code class=\"language-text\">GC 루트</code>들뿐 아니라 <code class=\"language-text\">구세대 객체까지</code> 모두 탐색해야 하며, 이 경우 성능 면에서 확실히 부담이 큽니다. 이 문제를 풀기 위해 <code class=\"language-text\">세대 단위 컬렉션 이론</code>에 <strong>3번째</strong> 가정이 추가됩니다.</p>\n<p><span style=\"color:orange\">3. 세대 간 참조 가설 : 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.</span></p>\n<p>상호 참조 관계의 두 객체는 <code class=\"language-text\">삶과 죽음을 함께하는 경향</code>이 있습니다. 신세대 객체가 세대 간 참조를 가지고 있을 때 구세대 객체는 잘 죽지 않기 때문에 가비지 컬렉션을 거쳐도 신세대 객체는 세대 간 참조 덕에 구세대로 승격됩니다. 이렇게 같은 세대가 되었으므로 세대 간 참조는 자연스럽게 사라게 됩니다.</p>\n<p>따라서 이 가설에 따르면 세대 간 참조의 수는 아주 적기 때문에 구세대 전체를 훑는 건 시간 낭비라고 판단합니다.</p>\n<h3 id=\"마크-스윕-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%A7%88%ED%81%AC-%EC%8A%A4%EC%9C%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"마크 스윕 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>마크-스윕 알고리즘</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/1c03ec5686b14ea083887c3f3ae33b77/2573e/mark-sweep-algorithm.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzElEQVR42jWSWW8bZRSG519xA0K5QCoCSkFsAlykQlFR0iZCQQ1JTdxGWZx6qZc63uPd43h3HNvjOo5jOyFx3OKapiIC1KLyPx6Op+Li1Wi+OfN873nPUV6cafx5UuP3TpF+JUq/HOWxlqG148dyZw6rcY7Nn2/pst6Z5cHyjzzK+DitpYg7VvCsLhCx3yVmN3HeLaH881jj5bDO+CDHqJUh79/k9vWvWLhhEMg0duMsKfcqqmcd9715bL/Msb8TkPo8QfMSlsWbzHx9hasfTHGyF0N5NdL4d9wUmMqgFiNsMXJ56g2uffIu9aSbSsTO/cVpzAs/YJq9xtL0NyzLc3X+ew6LQS6OKxhnrvLtx+8w1BIof5+UeTVqkPOtc8vwITe+eJ/PLr3Fl++9zU3DR8x/9ynb1iXC1kUMl6f4/NKbrP10HadpVhxF+GuwS867Rsxq5PwwOwGWeCmHx+UQGc8KWd8a+cCGLnXrHqWwmef9HH8c5dHSDvbiNobNGE/back9w/NeTtdFv8CLsyrK01aSgdx0Wo3QSruox+3UE3YeqS5G7ZRklWbQiOiQyftoP0kz7aQmNYN6RAePOyrnvSwXR0WUsQDHrTQnu2H21dfAluqkIT/k/GsUQxv0yj5pLyxuNykEN2QD3HQLXqoRC3tRK8NGnGfi9llbRfmtmRBgil7BTyV8n3Jok+NKiE7OS9S2RNK5zH72Id2Sj1bGpatb9In8dPJbAvbRLwYksgBPtDjKpN0zUTfvk1ZcaAkHBwJr73j0zBrJiR7QVB16DFrKQdp9l5TLJHA3/VKQctDMrhgZVMMov8owJvQj+XCQ3ZIc3XSyXsrbFhnKig6buKonbAJ16q4OC1u64+NqSLIPcypxDWvbMgsBHoqbbs5DPWrDbZojsH5bMnTrqzFjuEJSnExg6kOZeMhMW2r/B/ZLfjEiZsqvW+4VvPwHJs17iXKqppUAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mark sweep algorithm' title='' src='/static/1c03ec5686b14ea083887c3f3ae33b77/ca1dc/mark-sweep-algorithm.png' srcset='/static/1c03ec5686b14ea083887c3f3ae33b77/e7570/mark-sweep-algorithm.png 170w,\n/static/1c03ec5686b14ea083887c3f3ae33b77/f46e7/mark-sweep-algorithm.png 340w,\n/static/1c03ec5686b14ea083887c3f3ae33b77/ca1dc/mark-sweep-algorithm.png 680w,\n/static/1c03ec5686b14ea083887c3f3ae33b77/02d09/mark-sweep-algorithm.png 1020w,\n/static/1c03ec5686b14ea083887c3f3ae33b77/9d567/mark-sweep-algorithm.png 1360w,\n/static/1c03ec5686b14ea083887c3f3ae33b77/2573e/mark-sweep-algorithm.png 1380w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n가장 기본적인 가비지 컬렉션 알고리즘입니다. 먼저 회수할 객체들에 모두 표시(mark)한 다음, 표시된 객체들을 쓸어 담는(sweep) 방식입니다. 반대로, 살릴 객체에 표시(mark)하고, 표시되지 않은 객체를 회수(sweep) 하기도 합니다.</p>\n<h4 id=\"단점은\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90%EC%9D%80\" aria-label=\"단점은 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>단점은?</h4>\n<ul>\n<li>실행 효율이 일정하지 않음 : 자바 힙이 다량의 객체로 가득 차 있고 대부분이 회수 대상이라면? 표시하는 일 &#x26; 회수하는 일 모두 커짐 → 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어짐</li>\n<li>메모리 파편화가 심함 : 가비지 컬렉터가 쓸고 간 자리에는 불연속적인 메모리 파편이 만들어짐. → 파편화가 너무 심하면 프로그램이 큰 객체를 만들려 할 때 충분한 크기의 연속된 메모리를 찾기가 점점 어려워짐 → 또 다른 가비지 컬렉션 유발</li>\n</ul>\n<h3 id=\"마크-카피-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%A7%88%ED%81%AC-%EC%B9%B4%ED%94%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"마크 카피 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>마크-카피 알고리즘</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/c83d4b5d51797b6ba7b685c7fdc70aa7/64756/mark-copy-algorithm.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 58.235294117647065%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAADLklEQVR42i2SWVOaZxhA+R+9aGZy0Wkn0+lNp+2EMXFpVNxKNBpcUWtcAGMEWQRZRCMgRC24FDo2imsKRECrolFRUzXLJNqOndHkt5y+kl48892d93zPcySjgzaeOPvwWI14bL2MPXbg7bfQ2VyPRoyqsQ6Vsha3zURo1M3vfh/PpidJzE+Tis6TXo1wvJ3k3WGKy7MjJMN2E4O9Wmw9nRg0rdTfk1NVKqM49xbygrwM1KBupau1EYtWzYBJS8Dt4LcxD0uhACvhEOvPZthNLnH5/hCJ32Vn2G4UBgbMjzr45ovrfPf1VzjFIwNmnQAp6W5rygB7H6kEsBv/kI3giIvFoF8Ag5+A8UUuroCjj60MmrXcleWSJ/2WL699xo3rn1OSl8VPBbnU3SvlQU0F7UoFPapmzF3tDDuMXInMBHz8MT1Ocj7Ei+gcl6cHSEYGzAz16VBWlVFbXkzjfTnK+2U0VJagaqpmLjhCLDzFpLefKZ+T2QkvkZlx4gKSis6yt7rIy40Ir3cSfDgTwCGLln7DQ7Gnn9FrWjB1tYlpxW7QiIe0wr5bHEvPzKSX2Owka8vT7CYWSa8tc7QV481egrOXG5y/2ubj3/8DrdoOSu9kkX/7e4pypRRm36Qs/zaVpXeolsuEbSkOvYaAy8b0mEvsbYrkQpDtWJh0YomTVIx3e6vil/eReB0GnKZOymU5FOdJBegWspybyAtzUMgLqa0ookmswOvQi2RcRJ8G2P9ziYO1JY43o7x9EeefjOEWH07TSNzWHuw9apFItjD7QeQiJT9LmOZIBTSbqpIfaagoJvikn8TcBInwBPvJBQ7E7o42I5+Ah+ucH2/y8QroEPuziBw0zXW0NyjoaKymrb4q821vVKBurkEr0hl321kQB4oIw+3nc+zEF9hfXebV5nNO02vCcp2LtztI7CLo3ocdNCvKaamtFIFrUJQVZIxt+k48IhGP1ZCJeXbSx6++gcylNyJhcd0YJ1vxDPDfv1JcvNlFYtNpMoZGzQP06hbM3SqaBLzmbhE2nZohiw6nsYvRgT6e+j2YRAlGMYuhXzjZXuF4a4X3Anh+BXy9w3+uE2baBg26dAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mark copy algorithm' title='' src='/static/c83d4b5d51797b6ba7b685c7fdc70aa7/ca1dc/mark-copy-algorithm.png' srcset='/static/c83d4b5d51797b6ba7b685c7fdc70aa7/e7570/mark-copy-algorithm.png 170w,\n/static/c83d4b5d51797b6ba7b685c7fdc70aa7/f46e7/mark-copy-algorithm.png 340w,\n/static/c83d4b5d51797b6ba7b685c7fdc70aa7/ca1dc/mark-copy-algorithm.png 680w,\n/static/c83d4b5d51797b6ba7b685c7fdc70aa7/02d09/mark-copy-algorithm.png 1020w,\n/static/c83d4b5d51797b6ba7b685c7fdc70aa7/64756/mark-copy-algorithm.png 1200w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n회수할 객체가 많아질수록 효율이 떨어지는 마크-스윕 알고리즘의 문제를 해결하기 위해 생겨나게 되었습니다. 가용 메모리를 똑같은 크기의 두 블록으로 나눠서 한 번에 한 블록만 사용하고, 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록 목록을 한 번에 청소하는 방식입니다.</p>\n<p>만약 대다수 객체가 살아남으면? 메모리 복사에 상당한 시간 허비를 하게 됩니다.\n대다수 객체가 회수된다면? 생존한 소수의 객체만 복사하면 됨 &#x26; 복사 과정에서 객체들이 메모리 한쪽 끝에서 차곡차곡 쌓이기 때문에 메모리 파편화 문제로부터 해방됩니다.</p>\n<h3 id=\"단점은-1\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90%EC%9D%80-1\" aria-label=\"단점은 1 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>단점은?</h3>\n<p>가용 메모리를 절반으로 줄여 낭비가 제법 심하다는 점</p>\n<p>오늘날 상용 자바 가상 머신은 대부분 신세대에 이 알고리즘을 적용합니다.\nIBM의 연구에 따르면 신세대 객체 중 <code class=\"language-text\">98</code>%가 첫 번째 가비지 컬렉션에 살아남지 못했고, 이는 신세대용 메모리 영역을 1:1로 나눌 필요가 없다는 결론이 나게 됩니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/6f7f2f8d672f9ffec5a6dd08595fa600/51f47/young-gen-and-old-gen.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 63.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVR42o1SaW/aQBTk/39ppahV1NKqh4LTg4ZAOZJymGBOgwsFfGHAxvZiG4yh+AACSR9HRUu/dDT7tFrt7DtmfQ87PP4fTm76THOczxOVSrlKkmSlnM3iuq4f7v3Lv+GD1ZfVy9vcVbYSzBQ/p4thohYrUJFcJVasx8s/9kxUmhGixgk9SOYtFkexZk5fR3F/OOWPpF9F0i+uk2eB0DMs5A99e3mdPDCceoqFb5KZrtCZTqf70rZi27ZFSdJ1Q9ONoaYNkWZOrGa7TVKUgobiQO5LA0VF47Hpuu5p2cgYX+WqUBuUCjFcqCNjJCpIQpqgaOPZ/Ke7ZHoDBaHhECmKLIoizOWQGcTnwfjzD+Gzd5/OP0afvP/SoFlR1RptLl2sNhm+05OiqSzNcqCUFbnf76uqehCv1/cTgDmZWNbENEeGsdgBEu0a0YHQ1Hq9Pp22YehZPHNH5IlC8TaZZDrC6uHRcT3b9e7Xmz9tWq6WnuetVivIudlsDj13ZbXJdxXNKDXosTWz5jbFdnXTImnhTYIIpIoXyS2xVAlLk1gc1zTtOO2RNau12AbN5cg6zXdpTsiUalSLSZeoixh+eXMHxBLZQByH7/A2+FWSpIMYKoKd47j1ep36TjEM02q1Ab1ej2XpDs8JHZ7nOJ5jB2IfIpwghI5W7X8s9AOGL5fbUYGfEG3Hmc/ncAjLgec9z3Gd7ea3278AlpuyOpudEuYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='young gen and old gen' title='' src='/static/6f7f2f8d672f9ffec5a6dd08595fa600/ca1dc/young-gen-and-old-gen.png' srcset='/static/6f7f2f8d672f9ffec5a6dd08595fa600/e7570/young-gen-and-old-gen.png 170w,\n/static/6f7f2f8d672f9ffec5a6dd08595fa600/f46e7/young-gen-and-old-gen.png 340w,\n/static/6f7f2f8d672f9ffec5a6dd08595fa600/ca1dc/young-gen-and-old-gen.png 680w,\n/static/6f7f2f8d672f9ffec5a6dd08595fa600/51f47/young-gen-and-old-gen.png 892w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n신세대를 하나의 큰 에덴 공간(80%)과 두 개의 작은 생존자 공간(10%)으로 나누는데, 핫스팟 가상 머신에서 에덴과 생존자 공간의 비율은 기본적으로 8:1 (에덴 80% + 생존자 공간 중 하나 10%) 입니다. (낭비하는 공간은 단 10%뿐)</p>\n<ul>\n<li>\n<p>98%의 객체가 회수된다는 데이터 = ‘일반적인 상황'에서 측정된 결과</p>\n<blockquote>\n<p>😮 10% 넘는 객체가 살아남는 특이 케이스는 어쩌고? </p>\n</blockquote>\n</li>\n</ul>\n<p>이런 케이스에 대처하기 위한 설계로 <code class=\"language-text\">메모리 할당 보증 메커니즘</code> 개념이 등장합니다.</p>\n<h3 id=\"메모리-할당-보증-메커니즘\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%B3%B4%EC%A6%9D-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98\" aria-label=\"메모리 할당 보증 메커니즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>메모리 할당 보증 메커니즘</h3>\n<p>마이너 GC(신세대 GC)에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역(구세대)를 활용해 메모리 할당을 보증하는 것으로, 이러한 할당 보증 메커니즘을 통해 가비지 컬렉션에서 살아남은 객체를 구세대에 바로 추가합니다.</p>\n<h3 id=\"마크-컴팩트-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%A7%88%ED%81%AC-%EC%BB%B4%ED%8C%A9%ED%8A%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"마크 컴팩트 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>마크-컴팩트 알고리즘</h3>\n<p><code class=\"language-text\">마크-카피 알고리즘</code>은 객체 생존율이 높을수록 복사할 게 많아져서 효율이 나빠집니다. 공간을 50%나 낭비하기 싫다면 할당 보증용 공간을 따로 마련하여 대다수 객체가 살아남는 극단적 상황에 대처해야 하기 때문에 구세대에는 적합하지 않습니다. (객체 생존율이 높기 때문)</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/a998cb3743114039f2251e13585599cc/08188/mark-compact-algorithm.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 57.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAADCElEQVR42iWTa1MaZxTH+UJ12um0b5JmOn3bSdsYkwlNY0ASbWzG6YRatRpJTCTcBEEEDCCXBWGBZZergPGGNkbbmk7b7/Prgbw48+yc2ed/zv/ymMpqEa1copBTUAsFDL1Ks26QV7IUd3LD3uCfcqlAqZinYWgc7HVo1jS5k6UsPUMrstuo8t/f55iUTBolkyIS3iCw5mNxYZ7f5ucYGx3lu2+uc++uGavlHuY7t7k1NorXtUq3VWNleYn735uZtFqw/GBm/pcZ/jw/wqRrsl0+Sz6XIbQe4NrVq3xx5QquV04ZEpKej2gkyMsVB47lRdb9HrYTUV7HwpQKCiG/mzs3b2CfmeaPt4eYKmoBv8/NXbOZWzdH+fijET4ZGcFms/LzzGMmrOPYpL768hqff/Yp317/mttjN2TTF1ycHVFQkjyZeYTX+Yz3F8eYhlMCXmwT4zy0WZh8YGVKavKhhZ+mH6BrefpHHZ4tz/NoakI2C6JXcqKhytlJj+P9Fr22xslBi38vTzElYpukkrEhjdR2DCWbEDPSaHKpUStR14u0GmW6uwadtk6vo7PXNWhLr9OscPimQf+wzbvTHv8MAIMBH27XS36dtbMwN8vTxQWeO5YIh3wkXoelNshl42TSW2KeVCpKMZ8kndwUunHUfEJcVgS8zF8XYkoqHiXgc7H6woFz9Tk+j1PcdqEWM9Rku5pRHG601zE43G/KqdMXenu7OscHzWGdv33DmWx4OQCMBAMC4CEU8rMhldjaZCsaIimDcsr2kL5eLQi4SqupDSXotiWrhkpPQHsiw+/HXU6E9uX5gVBe8+L3usWYNYmIn6CcsUiYdCpONj3QMyXG7IimOxJ6laqcdaMkxux80LcmOvZaYooAvtsfAHpYcTxlzv4Ex9IgZz4eT//IpMRm3e8ll0myHY+Ijgmhrw7Bmo0KjXpZAFWhXhNjWpz1ux8A/R6XvIxBJKaYtdvxul0SHRvW++N4XE4SQj0WXieV2JIt5WlqQr8q2g5kkO92vSKGaPQlPhenPf4HIoKamwzjuQEAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mark compact algorithm' title='' src='/static/a998cb3743114039f2251e13585599cc/ca1dc/mark-compact-algorithm.png' srcset='/static/a998cb3743114039f2251e13585599cc/e7570/mark-compact-algorithm.png 170w,\n/static/a998cb3743114039f2251e13585599cc/f46e7/mark-compact-algorithm.png 340w,\n/static/a998cb3743114039f2251e13585599cc/ca1dc/mark-compact-algorithm.png 680w,\n/static/a998cb3743114039f2251e13585599cc/02d09/mark-compact-algorithm.png 1020w,\n/static/a998cb3743114039f2251e13585599cc/08188/mark-compact-algorithm.png 1176w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n이는 마크-컴팩트 알고리즘인데, 표시 단계는 <code class=\"language-text\">마크-스윕</code>과 같습니다. 회수 대상 객체들을 모두 쓸어 담는 대신 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비웁니다. </p>\n<h4 id=\"마크-스윕-알고리즘과의-차이는\" style=\"position:relative;\"><a href=\"#%EB%A7%88%ED%81%AC-%EC%8A%A4%EC%9C%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94\" aria-label=\"마크 스윕 알고리즘과의 차이는 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>마크-스윕 알고리즘과의 차이는?</h4>\n<blockquote>\n<p>💬 메모리 이동이 일어난다는 점</p>\n</blockquote>\n<p>그런데? 가비지 컬렉션 후 살아남은 객체를 이동할지는 양날의 검과 같은 결정입니다. 구세대에서는 회수 때마다 살아남는 객체가 상당히 많을텐데, 생존한 객체들을 이동시킨 후, 이동된 객체들을 가리키던 기존 참조를 모두 갱신하는 것은 매우 부담되고, 그렇다고 <code class=\"language-text\">마크-스윕 알고리즘</code>처럼 살아있는 객체를 전혀 이동시키지 않는다면 힙이 파편화되는 문제가 발생합니다. 그러나 이러한 문제는\n<span style=\"color:yellowgreen\">파편화 없는 할당 연결 리스트로 해결 가능</span>합니다.</p>\n<p>하드디스크나 SSD에는 물리적으로 연속된 공간이 없더라도 큰 파일을 저장할 수 있는 이유가 파일을 조각으로 나눠 물리적으로 떨어진 파티션에 저장한 다음 이를 파티션 테이블로 관리하기 때문입니다.</p>\n<p>대부분의 경우 메모리 파편화를 감내하면서 <code class=\"language-text\">마크-스윕</code>을 사용하다가, 객체 할당에 영향을 줄 만큼 파편화가 심해지면 <code class=\"language-text\">마크-컴팩트</code>를 돌려 연속된 공간을 확보하는 해법도 있습니다.</p>\n<h3 id=\"회고-및-마무리\" style=\"position:relative;\"><a href=\"#%ED%9A%8C%EA%B3%A0-%EB%B0%8F-%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"회고 및 마무리 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>회고 및 마무리</h3>\n<p>책의 내용이 방대하였기에, 회사 동료분들과 함께 각 챕터별로 담당자를 맡아서 핵심 개념을 요약하여 공유하는 방식을 통해 효율적으로 스터디할 수 있었던 것 같습니다. 또한 <code class=\"language-text\">JVM</code>을 공부하면 공부할수록 이 분야는 논문을 준비하는 대학원 석사 연구생들이 연구해봐도 좋을 것 같다라고 느낄정도로 심오하고도 깊은 내용이 많았습니다. 안드로이드 개발을 하다보면, 필요에 따라 빌드 구성 시 <code class=\"language-text\">JVM</code> 옵션을 설정할 때도 있는데, 이와 관련해서도 그동안 몰랐던 옵션들도 새롭게 알게 되었습니다. 업무를 하면서 <code class=\"language-text\">JVM, GC</code>와 관련하여 더 공부해보고 싶을 때, 이 책을 자주 찾을 것 같습니다.</p>","frontmatter":{"title":"책 『JVM 밑바닥까지 파헤치기』 후기","date":"August 21, 2024","update":"August 21, 2024","tags":["book"],"series":"독서"},"fields":{"slug":"/jvm-under-the-hood/","readingTime":{"minutes":21.18}}},"seriesList":{"edges":[{"node":{"id":"d2ebdb60-2bb2-53a8-82d4-5766746f2c97","fields":{"slug":"/jvm-under-the-hood/"},"frontmatter":{"title":"책 『JVM 밑바닥까지 파헤치기』 후기"}}}]},"previous":null,"next":{"fields":{"slug":"/aws-amplify/"},"frontmatter":{"title":"AWS Amplify Android 오픈소스 기여하기"}}},"pageContext":{"id":"d2ebdb60-2bb2-53a8-82d4-5766746f2c97","series":"독서","previousPostId":null,"nextPostId":"8e7bdff8-a60d-50a5-aa84-fbc6f7569ebb"}},"staticQueryHashes":[],"slicesMap":{}}