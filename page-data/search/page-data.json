{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"안드로이드 앱 개발 시 UI 변경사항이 제대로 적용되었는지 확인하는 과정은 필수적입니다. 특히 다양한 화면 크기와 해상도를 지원해야 하는 안드로이드 환경에서는 더욱 중요합니다. 하지만 코드 리뷰만으로는 이러한 UI 변경사항을 정확히 파악하기 어렵고, 특히 팀 규모가 커질수록 의도치 않은 UI 변경을 놓치기 쉽습니다. 최근 저는 회사 프로젝트에서 이 문제를…","fields":{"slug":"/roborazzi/"},"frontmatter":{"date":"March 09, 2025","title":"Roborazzi로 안드로이드 스크린샷 변경점 시각화 테스트 구축하기","tags":["robolectric","roborazzi"]},"rawMarkdownBody":"\n![](ui-testing.png)\n\n안드로이드 앱 개발 시 UI 변경사항이 제대로 적용되었는지 확인하는 과정은 필수적입니다. 특히 다양한 화면 크기와 해상도를 지원해야 하는 안드로이드 환경에서는 더욱 중요합니다. 하지만 코드 리뷰만으로는 이러한 UI 변경사항을 정확히 파악하기 어렵고, 특히 팀 규모가 커질수록 의도치 않은 UI 변경을 놓치기 쉽습니다.\n\n최근 저는 회사 프로젝트에서 이 문제를 해결하기 위해 [Roborazzi](https://github.com/takahirom/roborazzi)를 활용한 스크린샷 테스트 시스템을 구축했습니다. 이 글에서는 `Roborazzi`의 적용부터, `GitHub Actions`를 활용한 CI 파이프라인 구축까지의 경험을 공유하려고 합니다.\n\n## Roborazzi 소개\n\n[Roborazzi](https://github.com/takahirom/roborazzi)는 [Robolectric](https://robolectric.org/) 기반의 안드로이드 스크린샷 테스트 라이브러리입니다. Robolectric의 Native Graphics Mode(RNG)를 활용하여 JVM 환경에서 실행되는 안드로이드 통합 테스트를 시각화할 수 있게 해줍니다. 아직 Experimental 단계이지만, [Compose Multiplatform iOS](https://github.com/takahirom/roborazzi?tab=readme-ov-file#experimental-feature-ios-support)와 [Compose Desktop](https://github.com/takahirom/roborazzi?tab=readme-ov-file#experimental-feature-compose-desktop-support)도 실험적으로 지원하고 있습니다.\n\nRoborazzi의 가장 큰 장점은 실제 기기 없이 JVM 환경에서 스크린샷을 생성하고 비교할 수 있어, CI 환경에서 빠르게 테스트를 실행할 수 있다는 점입니다. 또한 Google의 공식 샘플 프로젝트인 [Now in Android](https://github.com/android/nowinandroid/blob/main/core/screenshot-testing/src/main/kotlin/com/google/samples/apps/nowinandroid/core/testing/util/ScreenshotHelper.kt)에도 적용되어 있어 실제 프로덕션 수준의 구현 예시를 찾아볼 수 있습니다.\n\n### Paparazzi와 Roborazzi 비교\n\n[Paparazzi](https://github.com/cashapp/paparazzi)는 JVM 환경에서 디스플레이를 시각화하는 훌륭한 도구이지만, 안드로이드 프레임워크를 모킹하는 Robolectric과는 호환되지 않습니다. Roborazzi는 이 간극을 메워줍니다. Robolectric과 통합되어 Hilt 등의 의존성 주입을 활용한 테스트가 가능하며, 실제 컴포넌트와 상호작용할 수 있습니다. 본질적으로 Roborazzi는 Paparazzi의 기능을 확장하여 Robolectric으로 스크린샷을 캡처함으로써 더 효율적이고 신뢰할 수 있는 테스트 프로세스를 제공합니다.\n\n### 주요 Gradle 태스크\n\nRoborazzi는 다음과 같은 Gradle 태스크를 제공합니다:\n\n| 태스크명 | 설명 |\n|---------|------|\n| **recordRoborazziDebug** | 스크린샷을 캡처하고 저장 |\n| **compareRoborazziDebug** | 현재 이미지와 저장된 이미지를 비교 |\n| **verifyRoborazziDebug** | 현재 이미지와 저장된 이미지 간의 차이 검증 |\n| **verifyAndRecordRoborazziDebug** | 이미지 검증 후 차이가 있으면 새 기준 이미지 기록 |\n| **clearRoborazziDebug** | 저장된 스크린샷 삭제 (실험적 기능) |\n\n## 프로젝트 설정\n\n### Gradle 설정\n\n먼저 프로젝트 레벨의 `build.gradle.kts`에 Roborazzi 플러그인을 추가합니다. \n\n```kotlin\n// root build.gradle.kts\nplugins {\n    // ...\n    id(\"io.github.takahirom.roborazzi\") version \"[version]\" apply false\n}\n```\n\n만약, buildScript 블록을 사용할 경우에는 아래와 같이 설정해줍니다.\n```kotlin\n// root build.gradle.kts\nbuildscript {\n  dependencies {\n    // ...\n    classpath(\"io.github.takahirom.roborazzi:roborazzi-gradle-plugin:[version]\")\n  }\n}\n```\n\n\n그리고 모듈 레벨의 `build.gradle.kts`에 다음과 같이 설정합니다.\n\n```kotlin\n// module build.gradle.kts\nplugins {\n    // ...\n    id(\"io.github.takahirom.roborazzi\")\n}\n\nandroid {\n    // 기존 설정\n    \n    testOptions {\n        unitTests {\n            isIncludeAndroidResources = true\n            // Robolectric의 하드웨어 렌더링 모드 사용\n            all {\n                it.systemProperties[\"robolectric.pixelCopyRenderMode\"] = \"hardware\"\n            }\n        }\n    }\n}\n\ndependencies {\n    // Core functions\n    testImplementation(\"io.github.takahirom.roborazzi:roborazzi:[version]\")\n\n    // Jetpack Compose\n    testImplementation(\"io.github.takahirom.roborazzi:roborazzi-compose:[version]\")\n\n    // JUnit rules\n    testImplementation(\"io.github.takahirom.roborazzi:roborazzi-junit-rule:[version]\")\n}\n\n// Roborazzi 설정\nroborazzi {\n    // 레퍼런스 이미지 저장 경로 설정\n    outputDir.set(file(\"src/test/screenshots\"))\n\n    // 비교 이미지 저장 경로 (Experimental option)\n    compare {\n        outputDir.set(file(\"build/outputs/screenshots_comparison\"))\n    }\n}\n```\n\n### gradle.properties 추가 설정\n\nRoborazzi는 `gradle.properties` 파일에서 다양한 옵션을 설정할 수 있습니다.\n\n```properties\n# 스크린샷 테스트 활성화 옵션\nroborazzi.test.record=true\n# roborazzi.test.compare=true\n# roborazzi.test.verify=true\n\n# 이미지 리사이즈 스케일 설정\nroborazzi.record.resizeScale=0.5\n\n# 파일 경로 전략 설정\n# 기본값은 relativePathFromCurrentDirectory\nroborazzi.record.filePathStrategy=relativePathFromRoborazziContextOutputDirectory\n\n# 이미지 포맷 설정 (WebP 지원, Experimental)\n# roborazzi.record.image.extension=webp\n\n# 오래된 스크린샷 자동 정리 (주의 필요)\n# roborazzi.cleanupOldScreenshots=true\n```\n\n## 스크린샷 테스트 작성\n\n이제 실제 스크린샷 테스트를 작성해보겠습니다. `Roborazzi`는 다양한 방식의 스크린샷 캡처를 지원하며, 주요 API는 다음과 같습니다:\n\n| 캡처 대상 | 코드 예시 |\n|---------|----------|\n| **Jetpack Compose** | `composeTestRule.onNodeWithTag(\"AddBoxButton\").captureRoboImage()` |\n| **Espresso View** | `onView(ViewMatchers.isRoot()).captureRoboImage()` |\n| **일반 View** | `view.captureRoboImage()` |\n| **Compose 람다** | `captureRoboImage { Text(\"Hello Compose!\") }` |\n| **전체 화면 (Experimental)** | `captureScreenRoboImage()` |\n| **Bitmap** | `bitmap.captureRoboImage()` |\n\n다음은 Jetpack Compose 기반 로그인 화면의 스크린샷 테스트 예시입니다:\n\n```kotlin\n@RunWith(RobolectricTestRunner::class)\n@GraphicsMode(GraphicsMode.Mode.NATIVE) // Robolectric Native Graphics 모드 활성화 (필수)\nclass LoginScreenshotTest {\n\n    @get:Rule\n    val composeTestRule = createComposeRule()\n    \n    @Test\n    fun captureLoginScreen_defaultState() {\n        // 컴포즈 UI 설정\n        composeTestRule.setContent {\n            MyAppTheme {\n                LoginScreen(\n                    uiState = LoginUiState.Default,\n                    onLoginClick = {},\n                    onEmailChanged = {},\n                    onPasswordChanged = {}\n                )\n            }\n        }\n        \n        // 스크린샷 캡처\n        composeTestRule.onRoot()\n            .captureRoboImage(\n                // 파일명 지정 (기본 출력 디렉토리에 저장됨)\n                \"loginScreen_defaultState\",\n                // 추가 옵션 설정\n                roborazziOptions = RoborazziOptions(\n                    // 이미지 리사이징\n                    recordOptions = RoborazziOptions.RecordOptions(\n                        resizeScale = 0.75f\n                    ),\n                    // 비교 옵션\n                    compareOptions = RoborazziOptions.CompareOptions(\n                        changeThreshold = 0.01f\n                    )\n                )\n            )\n    }\n    \n    @Test\n    fun captureLoginScreen_errorState() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                LoginScreen(\n                    uiState = LoginUiState.Error(\"Invalid credentials\"),\n                    onLoginClick = {},\n                    onEmailChanged = {},\n                    onPasswordChanged = {}\n                )\n            }\n        }\n        \n        // 특정 컴포넌트만 캡처할 수도 있음\n        composeTestRule.onNodeWithTag(\"errorMessage\")\n            .captureRoboImage(\n                \"loginScreen_errorMessage\"\n            )\n        \n        // 전체 화면 캡처\n        composeTestRule.onRoot()\n            .captureRoboImage(\n                \"loginScreen_errorState\"\n            )\n    }\n}\n```\n\n### RoborazziRule 활용\n\nRoborazzi는 JUnit 규칙을 통해 더 편리한 테스트 작성을 지원합니다. `RoborazziRule`은 선택적이지만, 다음과 같은 이점을 제공합니다.\n\n1. `RoborazziOptions`, `outputDirectoryPath` 등의 컨텍스트 제공\n2. 다양한 캡처 유형 설정 (LastImage, AllImage, Gif 등)\n\n```kotlin\n@RunWith(RobolectricTestRunner::class)\n@GraphicsMode(GraphicsMode.Mode.NATIVE)\nclass RuleTest {\n    @get:Rule\n    val composeTestRule = createComposeRule()\n    \n    @get:Rule\n    val roborazziRule = RoborazziRule(\n        composeRule = composeTestRule,\n        captureRoot = composeTestRule.onRoot(),\n        options = RoborazziRule.Options(\n            // 테스트 실패 시에만 이미지 캡처\n            captureType = RoborazziRule.CaptureType.Gif(onlyFail = true),\n            // 이미지 비교 옵션 설정\n            roborazziOptions = RoborazziOptions(\n                compareOptions = RoborazziOptions.CompareOptions(\n                    // 안티앨리어싱 문제 해결을 위한 설정\n                    imageComparator = SimpleImageComparator(\n                        maxDistance = 0.007f,\n                        vShift = 2,    // 수직 이동 허용\n                        hShift = 2     // 수평 이동 허용\n                    )\n                )\n            )\n        )\n    )\n    \n    @Test\n    // RoborazziRule 무시 어노테이션\n    // @RoborazziRule.Ignore\n    fun testWithRule() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                // ...\n            }\n        }\n        \n        // RoborazziRule이 테스트 실행 과정에서 자동으로 이미지 캡처\n    }\n}\n```\n\n### GIF 이미지 캡처\n\nRoborazzi는 애니메이션이나 사용자 상호작용을 보여주는 GIF 이미지 생성도 지원합니다:\n\n```kotlin\n@Test\nfun captureRoboGifSample() {\n    onView(ViewMatchers.isRoot())\n        .captureRoboGif(\"build/test.gif\") {\n            // 앱 실행\n            ActivityScenario.launch(MainActivity::class.java)\n            // 다음 페이지로 이동\n            onView(withId(R.id.button_first))\n                .perform(click())\n            // 뒤로 가기\n            pressBack()\n            // 다시 다음 페이지로 이동\n            onView(withId(R.id.button_first))\n                .perform(click())\n        }\n}\n```\n\n### 다양한 디바이스 설정 테스트\n\n실제 사용 환경을 더 잘 반영하기 위해 다양한 디바이스 설정(화면 크기, 방향, 다크 모드 등)에서 스크린샷을 캡처하는 것이 좋습니다. Roborazzi는 `RobolectricDeviceQualifiers`를 통해 미리 정의된 디바이스 설정을 제공합니다:\n\n```kotlin\n// 클래스 레벨에서 기본 디바이스 설정\n@RunWith(RobolectricTestRunner::class)\n@GraphicsMode(GraphicsMode.Mode.NATIVE)\n@Config(qualifiers = RobolectricDeviceQualifiers.Pixel5)\nclass DeviceSpecificScreenshotTest {\n    // ...\n}\n\n// 특정 테스트 메서드에만 다른 설정 적용\n@Test\n@Config(qualifiers = RobolectricDeviceQualifiers.MediumTablet + \"+land\")\nfun captureLoginScreen_landscapeTablet() {\n    // ...\n}\n\n// 다크 모드 설정\n@Test\n@Config(qualifiers = \"+night\")\nfun captureLoginScreen_darkMode() {\n    // ...\n}\n\n// 로케일 설정\n@Test\n@Config(qualifiers = \"+ja\")  // 일본어 로케일\nfun captureLoginScreen_japaneseLocale() {\n    // ...\n}\n```\n\n## 운영체제별 렌더링 차이\n\n다만, Roborazzi를 사용하면서 몇 가지 주의할 점들이 있습니다.\n\n### 1. OS별 렌더링 불일치 문제\n\nRoborazzi는 [Skia](https://skia.org/) 라이브러리를 사용하여 UI를 렌더링하는데, 이 렌더링 결과는 운영체제마다 약간씩 다를 수 있습니다. 이는 [FAQ - Why do my screenshot tests fail inconsistently across different operating systems like MacOS, Ubuntu, and Windows?](https://github.com/takahirom/roborazzi?tab=readme-ov-file#q-why-do-my-screenshot-tests-fail-inconsistently-across-different-operating-systems-like-macos-ubuntu-and-windows)에서도 언급된 노운 이슈입니다.\n\n이 문제는 Now in Android 프로젝트에서도 [논의된 바 있으며](https://github.com/android/nowinandroid/issues/1242#issuecomment-2032962982), 모든 환경에서 동일한 렌더링을 보장할 수 없다는 점이 확인되었습니다.  참고로 이러한 이유로 저의 로컬 PC(Mac)에서도 스크린샷 검증 태스크를 수행하면 실패하였습니다. 주요 원인은 다음과 같습니다.\n\n- 각 OS의 그래픽 드라이버 구현 차이\n- 폰트 렌더링 방식의 차이\n- 안티앨리어싱 처리 방식의 차이\n\n이 문제를 해결하기 위해 `RoborazziOptions.CompareOptions`의 옵션들을 변경해주어도 되겠지만, 저는 이렇게 조금씩 검증 조건을 완화해주다보면 스크린샷을 비교하는 의미가 없어진다는 생각이 들었습니다. 그래서 Roborazzi의 저자인 [takahirom](https://github.com/takahirom)님의 의견에 따라 일관성을 위해 기준 이미지 생성과 검증을 모두 동일한 CI 환경에서 수행하도록 구성하였습니다.\n\n![](now-in-android-roborazzi-compare-options.png)\n> 실제로 [nowinandroid](https://github.com/android/nowinandroid/blob/main/core/screenshot-testing/src/main/kotlin/com/google/samples/apps/nowinandroid/core/testing/util/ScreenshotHelper.kt)에서도 이미지 비교 옵션에 대해서는 타협하지 않은 점을 확인할 수 있습니다. \n\n### 2. 메모리 문제 해결\n\n복잡한 UI에서 많은 스크린샷 테스트를 실행할 경우 `OutOfMemoryError`가 발생할 수 있습니다. 이는 [Issue #272](https://github.com/takahirom/roborazzi/issues/272)에서도 논의된 문제로, 다음과 같이 `maxHeapSize`를 조정하여 해결할 수 있습니다.\n\n```kotlin\n// build.gradle.kts\nandroid {\n    testOptions {\n        unitTests.all {\n            maxHeapSize = \"4096m\"\n        }\n    }\n}\n```\n\n### 3. 깨진 이미지 문제 해결\n\n일부 경우에 Roborazzi로 캡처한 이미지가 깨져 보일 수 있습니다. 이는 주로 API 레벨이 너무 낮거나 Robolectric의 렌더링 모드 설정 문제일 수 있습니다. [Issue #255](https://github.com/takahirom/roborazzi/issues/255#issuecomment-1972838571)에서 논의된 것처럼, 다음과 같은 설정으로 해결할 수 있습니다.\n\n```kotlin\n// 테스트 클래스에 적용\n@Config(sdk = [35])  // 최신 API 레벨 사용\n@GraphicsMode(GraphicsMode.Mode.NATIVE)  // Native Graphics 모드 필수\n\n// build.gradle.kts\nandroid {\n    testOptions {\n        unitTests.all {\n            it.systemProperties[\"robolectric.pixelCopyRenderMode\"] = \"hardware\"\n        }\n    }\n}\n```\n이러한 설정을 통해 대부분의 렌더링 문제를 해결할 수 있었습니다.\n\n> 참고로 Robolectric 4.14 버전부터 Android V(SDK 35)를 지원합니다.\n![](robolectric-4.1.4.png)\n\n## CI 파이프라인 구축\n\n테스트를 작성한 후, 이를 CI 파이프라인에 통합하는 것이 중요합니다. 저는 GitHub Actions를 활용하여 PR이 생성될 때마다 스크린샷 테스트를 자동으로 실행하고, 변경사항이 있을 경우 시각적으로 표시하는 시스템을 구축했습니다.\n\n### GitHub Actions 워크플로우 구성\n\n다음은 GitHub Actions를 사용한 워크플로우 설정 예시입니다.\n\n```yaml\nname: Android Pull Request CI\n\non:\n  pull_request:\n    branches: [ main, develop ]\n\njobs:\n  verify-screenshots:\n    runs-on: ubuntu-latest\n    \n    permissions:\n      checks: write\n      pull-requests: write\n      contents: write\n      \n    steps:\n      - name: Checkout the code\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n        \n      - name: Set up JDK\n        uses: actions/setup-java@v4\n        with:\n          distribution: 'temurin'\n          java-version: '17'\n          cache: 'gradle'\n          \n      - name: Set up Android SDK\n        uses: android-actions/setup-android@v3\n        \n      - name: Grant execute permission for gradlew\n        run: chmod +x gradlew\n        \n      - name: Run ktlint\n        run: ./gradlew ktlintCheck\n        \n      # 스크린샷 검증 단계\n      - name: Verify Roborazzi Screenshots\n        id: screenshotsverify\n        continue-on-error: true\n        run: ./gradlew verifyRoborazziDebug\n        \n      # 검증 실패 시 새 스크린샷 생성\n      - name: Generate new screenshots if verification failed\n        id: screenshotsrecord\n        if: steps.screenshotsverify.outcome == 'failure'\n        run: ./gradlew recordRoborazziDebug\n        \n      # 브랜치명에서 JIRA 티켓 추출 (회사 상황에 맞게 조정)\n      - name: Extract JIRA ticket\n        id: extract_ticket\n        if: steps.screenshotsrecord.outcome == 'success'\n        run: |\n          BRANCH_NAME=$(echo ${{ github.head_ref }})\n          echo \"branch_name=$BRANCH_NAME\" >> $GITHUB_OUTPUT\n          \n          if [[ $BRANCH_NAME =~ (TICKET-[0-9]+) ]]; then\n            TICKET=\"${BASH_REMATCH[1]}\"\n            echo \"ticket=$TICKET\" >> $GITHUB_OUTPUT\n            echo \"Found JIRA ticket: $TICKET\"\n          else\n            echo \"ticket=NO-TICKET\" >> $GITHUB_OUTPUT\n            echo \"No JIRA ticket found in branch name\"\n          fi\n          \n      # 새 스크린샷 커밋\n      - name: Push new screenshots if available\n        uses: stefanzweifel/git-auto-commit-action@v5\n        if: steps.screenshotsrecord.outcome == 'success'\n        with:\n          file_pattern: '**/*.png'\n          disable_globbing: false\n          commit_message: \"${{ steps.extract_ticket.outputs.ticket != 'NO-TICKET' && format('{0} feat: 스크린샷 업데이트', steps.extract_ticket.outputs.ticket) || 'NO-TICKET feat: 스크린샷 업데이트' }}\"\n          \n      # 비교 이미지 수집\n      - name: Copy screenshot comparison files\n        id: copy_screenshots\n        if: steps.screenshotsverify.outcome == 'failure'\n        run: |\n          mkdir -p /tmp/screenshot-diff\n          \n          cd ${{ github.workspace }}\n          find . -name \"*_compare.png\" -exec cp {} /tmp/screenshot-diff/ \\;\n          \n          if [ -z \"$(find /tmp/screenshot-diff -type f -name '*.png')\" ]; then\n            echo \"No screenshot files found\"\n            echo \"has_images=false\" >> $GITHUB_OUTPUT\n          else\n            echo \"Found screenshot comparison images:\"\n            ls -la /tmp/screenshot-diff\n            echo \"has_images=true\" >> $GITHUB_OUTPUT\n          fi\n          \n      # Companion Branch 생성\n      - name: Create companion branch for screenshot comparison\n        id: companion_branch\n        if: steps.copy_screenshots.outputs.has_images == 'true'\n        run: |\n          BRANCH_NAME=\"screenshot-compare-${{ github.event.pull_request.number }}\"\n          echo \"branch_name=$BRANCH_NAME\" >> $GITHUB_OUTPUT\n          \n          git config --global user.name \"GitHub Actions\"\n          git config --global user.email \"actions@github.com\"\n          \n          git stash -u || true\n          \n          git branch -D \"$BRANCH_NAME\" || true\n          git checkout --orphan \"$BRANCH_NAME\"\n          git rm -rf .\n          \n          mkdir -p screenshot-diff\n          \n          cp /tmp/screenshot-diff/*.png screenshot-diff/\n          \n          git add screenshot-diff\n          git commit -m \"Add screenshot comparison results\"\n          git push origin \"$BRANCH_NAME\" -f\n          \n          echo \"companion_push_success=echo \"companion_push_success=true\" >> $GITHUB_OUTPUT\n\n          git checkout -f ${{ github.head_ref }} || git checkout -f HEAD\n          \n      # 마크다운 리포트 생성\n      - name: Generate markdown report for screenshot diffs\n        id: generate_report\n        if: steps.companion_branch.outputs.companion_push_success == 'true'\n        run: |\n          REPORT=\"## 📸 스크린샷 비교 결과\\n\\n\"\n          REPORT+=\"| 화면 이름 | 비교 이미지 |\\n\"\n          REPORT+=\"|:--------:|:----------:|\\n\"\n          \n          BRANCH_NAME=\"${{ steps.companion_branch.outputs.branch_name }}\"\n          \n          for FILE in /tmp/screenshot-diff/*.png; do\n            FILENAME=$(basename \"$FILE\")\n            SCREENNAME=${FILENAME%_compare.png}\n          \n            IMG_URL=\"https://github.com/${{ github.repository }}/blob/$BRANCH_NAME/screenshot-diff/$FILENAME?raw=true\"\n          \n            REPORT+=\"| \\`$SCREENNAME\\` | ![Screenshot]($IMG_URL) |\\n\"\n          done\n          \n          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)\n          echo \"report<<$EOF\" >> $GITHUB_OUTPUT\n          echo -e \"$REPORT\" >> $GITHUB_OUTPUT\n          echo \"$EOF\" >> $GITHUB_OUTPUT\n          \n          echo \"found_images=true\" >> $GITHUB_OUTPUT\n          \n      # 기존 PR 코멘트 찾기\n      - name: Find existing comment\n        uses: peter-evans/find-comment@v3\n        id: find_comment\n        if: steps.generate_report.outputs.found_images == 'true'\n        with:\n          issue-number: ${{ github.event.pull_request.number }}\n          comment-author: 'github-actions[bot]'\n          body-includes: '## 📸 스크린샷 비교 결과'\n          \n      # PR 코멘트 생성 또는 업데이트\n      - name: Create or update comment with comparison results\n        uses: peter-evans/create-or-update-comment@v4\n        if: steps.generate_report.outputs.found_images == 'true'\n        with:\n          comment-id: ${{ steps.find_comment.outputs.comment-id }}\n          issue-number: ${{ github.event.pull_request.number }}\n          body: ${{ steps.generate_report.outputs.report }}\n          edit-mode: replace\n          \n      # 단위 테스트 실행\n      - name: Run unit tests\n        run: ./gradlew testDebugUnitTest --stacktrace\n```\n\n위 과정에 성공하면 다음과 같이 정상적으로 코멘트가 생성되는 것을 확인할 수 있습니다.\n![(화면이름은 보안상 흰색박스로 가렸습니다.)](github-pr-comment-sample.png)\n\n이 워크플로우는 다음과 같은 순서로 동작합니다.\n1. PR이 생성되면 스크린샷 검증 작업(`verifyRoborazziDebug`)을 실행합니다.\n2. 검증에 실패하면(UI 변경이 있으면) 새로운 스크린샷을 생성합니다(`recordRoborazziDebug`).\n3. 브랜치 이름에서 JIRA 티켓 번호를 추출하여 커밋 메시지에 포함합니다. 이 부분은 각 회사나 팀의 작업 방식에 맞게 조정할 수 있습니다. (예를 들어, JIRA 대신 GitLab 이슈 번호나 다른 형식의 작업 ID를 사용할 수 있을 것 같습니다.)\n4. 스크린샷 비교 이미지를 별도의 임시 브랜치(companion branch)에 저장합니다.\n5. 비교 이미지를 포함한 마크다운 보고서를 생성하여 PR 코멘트로 추가합니다.\n\n### Companion Branch 접근법\n\n문득 이런 생각이 들 수도 있습니다. 스크린샷의 이미지가 과도하게 많아지면 저장소의 용량도 계속해서 증가하는 것은 아닐까?\n그래서 `Companion Branch Approach`가 [DroidKaigi/conference-app-2022](https://github.com/DroidKaigi/conference-app-2022/pull/616)에서 제안되었습니다.\n\n![](companion-branch-approach.png)\n\n제가 작성한 워크플로우는 비교 이미지들은 메인 코드베이스의 저장소 크기가 커지는 것을 방지하기 위해 임시 브랜치에 저장되어 관리되도록 하였지만, 레퍼런스 이미지들은 저장소에 커밋하고 있습니다. 첨부한 사진처럼 레퍼런스 이미지들도 GitHub Actions Artifact에 업로드하여 이를 `companion branch`에 생성한 비교이미지와 검증 태스크를 수행하는 방법으로 조금 더 개선할 수 있을 것 같습니다. 또한 Github Actions Artifact의 기본 보관 기간은 90일이지만, 보통 PR 생성 후 리뷰, 머지되기까지 길어봐야 1달 이내에 완료된다고 예상하면 보존 기간을 아래와 같이 30일로 설정할 수도 있습니다.\n\n```yaml\n- name: Store reference images as artifacts\n  uses: actions/upload-artifact@v4\n  with:\n    name: reference-screenshots\n    path: src/test/screenshots\n    retention-days: 30\n```\n> https://github.com/actions/upload-artifact?tab=readme-ov-file#retention-period\n\n## 결론\n\nRoborazzi를 활용한 스크린샷 테스트는 안드로이드 앱의 UI 품질을 높이는 데 큰 도움될 수 있습니다. 특히 CI 파이프라인과 통합하여 자동화된 UI 검증 시스템을 구축하면, 의도치 않은 UI 변경을 사전에 감지하고 시각적으로 확인할 수 있게 되어 좋았던 것 같습니다.\n참고로 해당 포스팅에서 Roborazzi의 모든 기능들을 전부 다룬 것은 아닙니다. [릴리즈](https://github.com/takahirom/roborazzi/releases)가 될때마다 신규 기능 추가 및 변경사항들을 꾸준히 모니터링하는 것이 중요할 것 같습니다.\n\n## 참고 자료\n\n- https://github.com/takahirom/roborazzi\n- https://github.com/android/nowinandroid/blob/main/core/screenshot-testing/src/main/kotlin/com/google/samples/apps/nowinandroid/core/testing/util/ScreenshotHelper.kt\n- https://github.com/android/nowinandroid/issues/1242#issuecomment-2032962982\n- https://github.com/DroidKaigi/conference-app-2022/pull/616\n- https://github.com/takahirom/roborazzi-compare-on-github-comment-sample\n- https://robolectric.org/configuring/"},{"excerpt":"안드로이드 개발에서 테스팅은 애플리케이션의 품질을 보장하는 중요한 단계입니다. 특히 JUnit은 자바와 코틀린 환경에서 가장 널리 사용되는 테스팅 프레임워크이지만, JUnit4와 JUnit5 사이에는 상당한 차이가 있으며 이는 안드로이드 테스트 환경에서 여러 문제를 일으킬 수 있습니다. 이 글에서는 JUnit4와 JUnit5의 주요 차이점, Robolec…","fields":{"slug":"/junit4-junit5/"},"frontmatter":{"date":"March 07, 2025","title":"JUnit4 vs JUnit5 그리고 Robolectric 호환성 문제 해결하기","tags":["testing","junit","robolectric"]},"rawMarkdownBody":"\n안드로이드 개발에서 테스팅은 애플리케이션의 품질을 보장하는 중요한 단계입니다. 특히 JUnit은 자바와 코틀린 환경에서 가장 널리 사용되는 테스팅 프레임워크이지만, JUnit4와 JUnit5 사이에는 상당한 차이가 있으며 이는 안드로이드 테스트 환경에서 여러 문제를 일으킬 수 있습니다. 이 글에서는 JUnit4와 JUnit5의 주요 차이점, Robolectric이 JUnit4만 지원하는 제약을 해결하는 방법에 대해 알아보겠습니다.\n\n## JUnit4 vs JUnit5\n\n![](junit5-release.png)\n\n`JUnit5`는 [2017년 9월 10일에 처음 릴리즈](https://junit.org/junit5/docs/5.1.0/release-notes/index.html#release-notes-5.0.0) 되었습니다. `JUnit4`보다 여러 면에서 개선되었는데,가장 큰 차이점들을 살펴보겠습니다.\n\n### 1. 아키텍처 차이\n\n**JUnit4**:\n- 단일 `jar` 파일로 제공\n- 모놀리식 아키텍처\n\n**JUnit5**:\n- 모듈화된 구조\n  - `JUnit Platform`: 테스트 실행을 위한 기반\n  - `JUnit Jupiter`: 새로운 테스트 API\n  - `JUnit Vintage`: JUnit3, JUnit4 호환성 지원\n\n### 2. 어노테이션 변경\n\n| JUnit4 | JUnit5 | 설명 |\n|--------|--------|------|\n| `@Before` | `@BeforeEach` | 각 테스트 메서드 전에 실행 |\n| `@After` | `@AfterEach` | 각 테스트 메서드 후에 실행 |\n| `@BeforeClass` | `@BeforeAll` | 클래스의 모든 테스트 전에 실행 |\n| `@AfterClass` | `@AfterAll` | 클래스의 모든 테스트 후에 실행 |\n| `@Ignore` | `@Disabled` | 테스트 비활성화 |\n| N/A | `@DisplayName` | 테스트에 사용자 정의 이름 부여 |\n\n### 3. 새로운 기능들\n\n**JUnit5**에서 추가된 주요 기능들:\n- **중첩 테스트**: `@Nested` 어노테이션\n- **태그 필터링**: `@Tag` 어노테이션\n- **파라미터화된 테스트 개선**: `@ParameterizedTest`, `@ValueSource`, `@CsvSource` 등\n- **확장 모델**: `@ExtendWith` 사용\n- **조건부 테스트 실행**: `@EnabledOnOs`, `@EnabledIfSystemProperty` 등\n- **인터페이스 기본 메서드로 테스트 선언 지원**\n\n```kotlin\n// JUnit4 예시\n@Test\n@Category(SlowTests.class)\npublic void myTest() {\n    // 테스트 코드\n}\n\n// JUnit5 예시\n@Test\n@Tag(\"slow\")\n@DisplayName(\"샘플 테스트\")\nvoid myTest() {\n    // 테스트 코드\n}\n```\n\n## 안드로이드에서의 JUnit4와 JUnit5\n\n안드로이드 테스트 환경은 주로 `JUnit4`를 기반으로 구축되어 있습니다. 실제로 많은 사용해보셨을만한 아래의 안드로이드 테스팅 라이브러리들이 여전히 `JUnit4` 기반으로 동작합니다.\n\n1. [Espresso](https://developer.android.com/training/testing/espresso?hl=en)\n2. [AndroidX Test APIs](https://developer.android.com/jetpack/androidx/releases/test?hl=en)\n3. [Mockito](https://site.mockito.org/)\n4. [PowerMock](https://github.com/powermock/powermock?tab=readme-ov-file)\b\n5. [Hamcrest](https://hamcrest.org/)\n\n이러한 라이브러리들은 대부분 JUnit4의 `@RunWith`, `@Rule` 등을 기반으로 작동합니다.\n\n최근에 회사에서 스크린샷 통합 테스트 구축 작업을 진행하다가, 기존의 테스트 코드들이 `Junit5` 기반으로 동작하고 있어서 JVM UI 테스트를 위해 [Robolectric](http://robolectric.org/)을 셋업하는 과정에서 여러 이슈가 있었습니다.\n\n### Robolectric\n\n간단하게 설명하자면, [Robolectric](http://robolectric.org/)은 안드로이드 UI 테스트를 JVM 에서 실행할 수 있게 해주는 강력한 도구입니다. 그러나 아쉽게도 `Robolectric`은 현재까지도 `JUnit4` 기반에서만 동작합니다.\n\n참고로, 이와 관련한 오픈 이슈도 있습니다.\n![https://github.com/robolectric/robolectric/issues/3477](robolectric-junit5-support-issue.png)\n\n`Robolectric`의 핵심 기능은 JUnit4의 `@RunWith` 어노테이션을 사용하여 작동하고 있고, 아래의 예시처럼 사용할 수 있습니다.\n\n```kotlin\n// Robolectric 테스트 예시\n@RunWith(RobolectricTestRunner::class)\nclass MyRobolectricTest {\n    @Test\n    fun testButton_click() {\n        val activity = Robolectric.setupActivity(MyActivity::class.java)\n        val button = activity.findViewById<Button>(R.id.my_button)\n        button.performClick()\n        // 검증 로직\n    }\n}\n```\n\n## JUnit5를 안드로이드에 적용하기\n\nGradle 테스트를 위해 `JUnit5`를 사용하려면 `useJUnitPlatform()` 구성이 필요합니다.\n\n![](use-junit-platform-description.png)\n\n```kotlin\n// build.gradle.kts\ntasks.withType<Test> {\n    useJUnitPlatform()\n}\n\ndependencies {\n    testImplementation(\"org.junit.jupiter:junit-jupiter-api:5.9.3\")\n    testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:5.9.3\")\n}\n```\n\n그렇다면 `JUnit5`와 `Robolectric`을 함께 사용하려면 어떻게 해야할까요?\n\n앞서 설명했던 `JUnit Vintage`를 사용하시면 됩니다.\n\n![https://junit.org/junit5/docs/current/user-guide/](junit-vintage-description.png)\n\n`JUnit Vintage`는 JUnit3와 JUnit4 기반의 테스트를 위해 테스트 엔진을 제공해줍니다.\n\n```kotlin\n// build.gradle.kts\ndependencies {\n    testRuntimeOnly(\"org.junit.vintage:junit-vintage-engine:5.9.3\")\n}\n```\n\n이 방법으로 `JUnit4 + Robolectric 테스트`를 `JUnit5` 환경에서 실행할 수 있게 되었습니다.\n\n## 결론\n\n안드로이드 개발 생태계에서는 당분간 JUnit4, JUnit5 두 버전이 공존할 것으로 보입니다. `Robolectric`과 같은 중요한 도구들이 여전히 JUnit4에 의존하고 있기 때문에, 점진적 전환 접근 방식이 현실적일 것 같습니다.\n\n1. 새로운 단위 테스트에 JUnit5 사용하기\n2. UI 및 통합 테스트에는 JUnit4 + Robolectric 유지하기\n3. JUnit Vintage를 통해 두 환경 통합하기\n4. (중요) 커뮤니티의 진행 상황을 주시하며 점차적으로 전환 계획 세우기\n\n## 참고\n- https://junit.org/junit5/docs/5.1.0/release-notes/index.html#release-notes-5.0.0\n- https://github.com/robolectric/robolectric/issues/3477 \n- https://junit.org/junit5/docs/current/user-guide/\n- https://github.com/android/android-test/issues/409\n- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api\n- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine\n- https://mvnrepository.com/artifact/org.junit.vintage/junit-vintage-engine"},{"excerpt":"안드로이드 앱을 개발하다 보면 UI는 완벽해 보여도(적어도 프로덕트 디자이너분들께서 요구하는 사항들을 전부 만족하더라도?), 사용자 경험(UX) 측면에서 사소하지만 치명적인 요소들을 간과하기 쉽습니다. 특히 피츠의 법칙(Fitts’ Law)을 이해하면 버튼 터치 영역, 제스처 동작 등에서 흔히 놓치는 UX 포인트를 개선할 수 있습니다. 이번 글에서는 피츠…","fields":{"slug":"/fitts-law/"},"frontmatter":{"date":"March 04, 2025","title":"안드로이드 개발자가 놓치기 쉬운 UX (feat. 피츠의 법칙)","tags":["ux"]},"rawMarkdownBody":"\n안드로이드 앱을 개발하다 보면 UI는 완벽해 보여도(적어도 프로덕트 디자이너분들께서 요구하는 사항들을 전부 만족하더라도?), 사용자 경험(UX) 측면에서 사소하지만 치명적인 요소들을 간과하기 쉽습니다. 특히 **피츠의 법칙(Fitts’ Law)**을 이해하면 버튼 터치 영역, 제스처 동작 등에서 흔히 놓치는 UX 포인트를 개선할 수 있습니다. 이번 글에서는 피츠의 법칙 개념부터 시작해, 안드로이드 개발자가 챙겨야 할 UX 요소들과 실제 개선 방법을 살펴보겠습니다.\n\n### 피츠의 법칙?\n![](fitts_law.png)\n\n피츠의 법칙은 간단히 말해 *“목표(target)까지의 거리(D)가 멀수록, 그리고 목표 크기(W)가 작을수록 도달(클릭/터치) 시간이 늘어난다”*는 인간 동작 모델입니다. 원래는 마우스 커서 같은 포인터 이동에 대한 연구였지만, 터치스크린 환경에도 그대로 응용됩니다. 사용자가 화면에서 버튼을 누를 때 걸리는 시간은 버튼의 크기와 현재 손가락 위치로부터의 거리에 영향을 받습니다.\n\n\n![](fitts_law_2.png)\n> 클릭/터치 시간 T는 거리(D)와 크기(W)의 함수로 나타낼 수 있습니다. 예를 들어 Target A와 B의 크기가 동일하다면, 손가락/포인터에서 가까운 A를 더 빨리 누를 수 있고, Target C처럼 크기가 작은 경우 가까이 있어도 시간이 더 걸립니다.\n\n모바일에서는 피츠의 법칙이 더욱 **중요**합니다. 손가락이 직접 화면을 터치하는 방식이기 때문인데, 마우스 포인터는 화면의 작은 영역도 정확히 가리킬 수 있지만, 손가락은 크기도 크고 터치할 때 화면을 가려서 정교함이 떨어집니다. 실제로도 제 엄지손가락이 남들보다 굵은 편이라 터치할 때 버튼이 작으면 터치하기가 불편했던 경험이 많았습니다. 다시 말해, 터치는 마우스보다 `정밀도가 낮은 입력 수단`입니다. 따라서 안드로이드 UI를 개발할 때 터치 대상은 충분히 크게, 그리고 조작 영역에서 너무 멀리 떨어져 있지 않게 배치하는 것을 고려하는 것이 좋습니다. `피츠의 법칙`에 따르면 작은 버튼이나 구석진 위치의 메뉴는 사용자가 누르기 어렵고 시간도 더 걸리므로, UX를 해치게 됩니다.\n\n또 한 가지, 터치 목표 사이의 간격도 고려해야 합니다. 버튼들이 너무 촘촘하거나 작으면 사용자는 원하는 대상을 누르기 힘들고, 잘못 눌러 오동작(잘못된 대상 터치)할 확률이 높아집니다. 이는 사용자가 인터페이스를 불편하게 느끼게 만드는 요인이 됩니다.\n\n### 개발에는 어떻게 적용해볼까?\n\nAndroid UI를 개발할 때, **클릭 리스너(OnClickListener)**를 UI 요소의 특정 뷰에만 걸어두고, 정작 사용자가 누를 수 있는 실제 영역은 아주 좁게 남아있는 경우가 흔합니다. 예를 들어 리스트 아이템 전체를 눌러야 할 것 같지만, 개발자가 아이콘이나 텍스트 뷰에만 리스너를 달면 사용자는 빈 공간을 눌렀을 때 반응이 없어 당황하게 됩니다. 이는 피츠의 법칙 측면에서 보면 목표 영역이 불필요하게 작아진 사례입니다.\n\n이런 문제는 터치 영역을 확장함으로써 해결할 수 있습니다. 안드로이드 Material Design 가이드라인에서도 *“아이콘이 24dp로 보여도 주변 패딩을 합쳐 실제 터치 영역은 48x48dp로 만들어야 한다”*고 권장합니다. 또한 `android:padding`이나 `TouchDelegate` 등을 활용해 버튼 주위의 투명한 공간도 클릭을 감지하도록 개발하는 방법도 있습니다. 전체 레이아웃을 클릭 가능하게 옵션을 주거나, 터치 영역을 넓히는 것도 방법이 될 수 있습니다.\n\n### 햅틱 피드백(Haptic Feedback)도 있다\n\n앱을 사용하다 보면 진동 피드백을 통해 눌림이나 동작 완료를 느낄 때가 있습니다. 바로 `햅틱 피드백`인데요, 저는 이전에 창업을 하여 [Preat](https://play.google.com/store/apps/details?id=com.freetreechair.preat&pli=1)이라는 서비스를 개발할 때, 이를 구현했었던 경험이 있습니다. 그런데 간혹가다가 기능 구현에 몰두하다 보면 이러한 햅틱 피드백을 잊는 경우도 많습니다. 가령 롱프레스(길게 누르기) 동작이나 드래그 앤 드롭, 또는 스와이프 제스처 등에서 짧은 진동을 주면 사용자는 `“지금 동작이 인식됐구나”`를 직감적으로 알 수 있습니다.\n\n안드로이드에서는 Vibrator 클래스를 통해 쉽게 `햅틱`을 구현할 수 있습니다.\n\n```kotlin\nColumn(\n    modifier = Modifier.fillMaxSize(),\n    horizontalAlignment = Alignment.CenterHorizontally,\n    verticalArrangement = Arrangement.Center\n) {\n    // Vibration Controller\n    val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator\n\n    // Vibration Button - OneShot\n    Button(onClick = {\n        // Safely cancel any ongoing vibrations\n        vibrator.cancel()\n\n        // Handling vibrations for Android 8.0 (Oreo) and above\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            val effect = VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE)\n            vibrator.vibrate(effect)\n        } else {\n            // Handling vibrations for devices below Android 8.0\n            vibrator.vibrate(100)\n        }\n    }) {\n        Text(text = \"Vibration Button OneShot\")\n    }\n\n    // Vibration Button - Predefined Effect (Android 10 or above)\n    Button(onClick = {\n        // Safely cancel any ongoing vibrations\n        vibrator.cancel()\n\n        // Checking for Android 10 or above\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            val effect = VibrationEffect.createPredefined(VibrationEffect.EFFECT_CLICK)\n            vibrator.vibrate(effect)\n        } else {\n            // Handling vibrations for devices below Android 10\n            vibrator.vibrate(100)\n        }\n    }) {\n        Text(text = \"Vibration Button Predefined\")\n    }\n}\n```\n\n> 개인적으로 진동을 너무 잦게 혹은 강하게 주면 오히려 거슬리다고 느낀 경험이 있어, 상황에 맞는 패턴과 세기를 선택하는 것이 중요할 것 같습니다.\n\n### Android Predictive Back API는 또 뭔데?\n\n안드로이드 13부터 도입된 `Predictive Back 제스처(예측성 뒤로 가기)`는 UX 향상을 위한 새로운 시스템 기능입니다. `Predictive Back`을 적용하면 사용자가 뒤로 스와이프 제스처를 시작하는 순간 다음 화면을 미리 보여주는 애니메이션이 나타납니다. 이를 통해 사용자는 이 제스처를 계속 하면 어디로 갈지 미리 확인하고 결정할 수 있게 됩니다.\n\n![](predictive-back-nav-home.gif)\n\nAndroid 15부터는 개발자 옵션 설정 없이 디폴트로 볼 수 있고, [AndroidX Activity 1.6.0-alpha05](https://developer.android.com/jetpack/androidx/releases/activity#1.6.0-alpha05) 이후의 버전으로 업데이트하고, `Manifest`파일의 `application` 태그에 `android:enableOnBackInvokedCallback=“true”`를 적용하면 시스템이 뒤로 가기 제스처를 미리 알고 애니메이션을 처리할 수 있게 됩니다.\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    ...\n    <application\n        ...\n        android:enableOnBackInvokedCallback=\"true\">\n        ...\n    </application>\n\n</manifest>\n```\n\n> 만약 `android:enableOnBackInvokedCallback` 플래그를 `false`로 설정해두면, 시스템은 `OnBackInvokedCallback` 구현부에서 호출하는 동작을 모두 무시하게 됩니다. 대신 여전히 하위 호환성을 위해 기존의 `onBackPressed API`를 호출하므로, `OnBackPressedCallback`은 계속 정상적으로 동작하게 됩니다.\n\n만약 유저의 Back 제스처로 곧바로 이전 화면을 보여주고 싶지 않을 때(예를 들어, 유저에게 정말로 뒤로가고 싶은지 물어보는 다이얼로그를 노출하고 싶을 때)에는 아래와 같이 구현하면 됩니다.\n```kotlin\nprivate val onBackPressedCallback: OnBackPressedCallback = object : OnBackPressedCallback(true) {\n    override fun handleOnBackPressed() {\n        //your custom onBackPressed logic\n        showConfirmationDialog()\n    }\n}\n```\n\n그리고, 이 callback을 `OnBackPressedDispatcher`에 추가하면 끝입니다.\n```kotlin\nonBackPressedDispatcher.addCallback(onBackPressedCallback)\n```\n\n더 자세히 적용해보고 싶다면, 아래 코드랩 링크들을 참고하면 도움이 될 것 같습니다.\n- https://codelabs.developers.google.com/handling-gesture-back-navigation\n- https://developer.android.com/guide/navigation/custom-back/predictive-back-gesture\n\n### 결론\n\n지금까지 `피츠의 법칙`을 중심으로 설명한 UX 요소들은 개선은 결국 사용자를 위한 배려라고 볼 수 있습니다. 버튼의 터치 영역을 넓히고, 손가락이 닿는 범위를 고려해 배치하는 등 개발 단계에서 조금만 신경 쓰면 사용자 불편을 크게 줄일 수 있다고 생각합니다.\n\n특히 안드로이드 앱은 다양한 기기 화면 크기와 사용 환경에서 실행되므로, 보편적인 UX 원칙을 지키는 것이 중요합니다. 이렇게 개발자가 UX를 먼저 고려한다면 기획 단계에서부터 완성도 높은 서비스를 만들 수 있고, 회사에서 기획자나 디자이너와의 의사소통도 원활해질 수 있을 것이라고 생각합니다. 특히 저도 자주 놓치는 부분이기는 하지만, 안드로이드 개발자로서 UI 개발을 하다보면 과연 내가 `Material Design이나 안드로이드 접근성 가이드 등 권장사항을 따르고 있는가?` 라고 끊임없이 되묻는 자세가 필요한 것 같습니다.\n\n작은 버튼 하나, 진동 한 번의 차이가 모여 앱의 성공을 결정짓는 UX를 만들 수 있다는 점을 믿으며, 놓치기 쉬운 UX 요소들을 챙기는 습관이 AI 시대의 프로덕트 엔지니어로서 곧 사용자의 행복을 만들 수 있다고 생각합니다.\n\n### 참고 자료\n- [[Accessibility] Why the recommended touch target size on android devices is 48 x 48 dp?](https://github.com/material-components/material-components-android/issues/1279)\n- [Android Vibrations in Jetpack Compose](https://medium.com/@EazSoftware/everything-you-need-to-know-about-android-vibrations-cf8759b15121)\n- [뒤로 탐색 예측 동작 지원 추가](https://developer.android.com/guide/navigation/custom-back/predictive-back-gesture?hl=ko)\n- [What Is Predictive Back Gesture?](https://pl-coding.com/2024/10/26/predictive-back-support/#:~:text=You%20can%20see%20predictive%20back,the%20predictive%20back%20gesture%20animations)\n- [Predictive Back Gesture On Android](https://adiandrea.medium.com/predictive-back-gesture-on-android-31610b1b58b7)"},{"excerpt":"AWS Amplify는 모바일 및 프런트엔드 개발자가 AWS에서 안전하고 확장 가능한 풀스택 애플리케이션을 구축하고 배포할 수 있도록 지원하는 제품입니다. 회사에서 서비스하고 있는 프로젝트에서 S3로 로그 파일을 주기적으로 업로드하는 기능을 구현하고 꾸준히 모니터링하였는데, 여러 Android 기기에서 java.lang.OutOfMemoryError 오류…","fields":{"slug":"/aws-amplify/"},"frontmatter":{"date":"February 25, 2025","title":"AWS Amplify Android 오픈소스 기여하기","tags":["opensource"]},"rawMarkdownBody":"\nAWS Amplify는 모바일 및 프런트엔드 개발자가 AWS에서 안전하고 확장 가능한 풀스택 애플리케이션을 구축하고 배포할 수 있도록 지원하는 제품입니다. 회사에서 서비스하고 있는 프로젝트에서 S3로 로그 파일을 주기적으로 업로드하는 기능을 구현하고 꾸준히 모니터링하였는데, 여러 Android 기기에서 [java.lang.OutOfMemoryError](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html) 오류가 반복적으로 발생하는 것을 발견했습니다.\n\n### 원인을 분석해보자\n수집된 크래시 리포트를 요약하면 다음과 같았습니다.\n```text\nFatal Exception: java.lang.OutOfMemoryError: Failed to allocate a 8388620 byte allocation with 8388608 free bytes and 19MB until OOM\n       at java.util.IdentityHashMap.resize(IdentityHashMap.java:476)\n       at java.util.IdentityHashMap.put(IdentityHashMap.java:452)\n       ...\n       at com.amplifyframework.storage.s3.transfer.TransferWorkerObserver$attachObserver$2.invokeSuspend(TransferWorkerObserver.kt:199)\n```\n\n[TransferWorkerObserver](https://github.com/aws-amplify/amplify-android/blob/main/aws-storage-s3/src/main/java/com/amplifyframework/storage/s3/transfer/TransferWorkerObserver.kt) 클래스에서 동일한 전송 태그에 대해 `LiveData.observeForever()`가 중복 호출되며, 여러 관찰자가 등록된 것으로 보였고, 이는 `LiveData` 내부의 [IdentityHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html)이 과도하게 커져 메모리 할당에 실패하게 만들고, 특히 `Room` 라이브러리의 [InvalidationTracker](https://developer.android.com/reference/androidx/room/InvalidationTracker)와 연계된 `LiveData` 사용으로 메모리 사용량이 더 증가한 것으로 판단하였습니다.\n\n### 이슈 등록하기\n저는 먼저 이 문제를 공유하기 위해 템플릿에 맞추어 [이슈](https://github.com/aws-amplify/amplify-android/issues/2840)를 등록해주었습니다.\n\n다만, **보안상** 회사 코드를 전부 스니펫에 첨부할 수는 없었기 때문에 민감한 코드는 전부 제거하고 핵심 로직만 다시 재작성하였습니다. 이슈란에 첨부한 코드 스니펫은 다음과 같았습니다.\n\n```kotlin\n@HiltWorker\nclass LogUploadWorker @AssistedInject constructor(\n    @Assisted private val appContext: Context,\n    @Assisted workerParams: WorkerParameters,\n    @Dispatcher(IO) private val ioDispatcher: CoroutineDispatcher\n) : CoroutineWorker(appContext, workerParams) {\n\n    override suspend fun getForegroundInfo(): ForegroundInfo =\n        appContext.logSyncForegroundInfo()\n\n    override suspend fun doWork(): Result = withContext(ioDispatcher) {\n        try {\n            val externalFilesDirPath = inputData.getString(\"externalFilesDirPath\")\n            val externalFilesDir = externalFilesDirPath?.let { File(it) }\n            if (externalFilesDir != null && externalFilesDir.exists()) {\n                uploadLogFiles(externalFilesDir)\n            }\n        } catch (e: Exception) {\n            Timber.e(\"Log upload exception: ${e.message}\")\n            Result.retry()\n        }\n        Result.success()\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class, FlowPreview::class)\n    private suspend fun uploadLogFiles(externalFilesDir: File) {\n        val curFiles = externalFilesDir.listFiles()?.filter { file ->\n            System.currentTimeMillis() - file.lastModified() < TWO_WEEK_TIME_MILLIS\n        }?.sortedByDescending { it.lastModified() }\n\n        if (curFiles.isNullOrEmpty()) {\n            Timber.i(\"No log files or directory found.\")\n            return\n        }\n        \n        val environmentPrefix = if (BuildConfig.DEBUG) \"debug\" else \"release\"\n        val dateFormat = SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault())\n\n        curFiles.forEach { file ->\n            val date = dateFormat.format(Date(file.lastModified()))\n            val fileIndex = file.name.substringBefore(\"_logs.txt\").takeLastWhile { it.isDigit() }\n            val key = \"$environmentPrefix/sample/$date/log$fileIndex.txt\"\n\n            try {\n                val result = Amplify.Storage.uploadFile(\n                    StoragePath.fromString(\"public/$key\"),\n                    file\n                ).result()\n                Timber.i(\"Log file upload successful: ${result.path}\")\n            } catch (error: Exception) {\n                Timber.e(\"Log file upload failed: ${error.message} - ${error.cause}\")\n            }\n        }\n    }\n\n    companion object {\n        private const val TWO_WEEK_TIME_MILLIS = 14 * 24 * 60 * 60 * 1000L\n\n        fun startUpUploadWork(\n            externalFilesDirPath: File?\n        ) = PeriodicWorkRequestBuilder<LogUploadWorker>(\n            1, TimeUnit.HOURS,\n            5, TimeUnit.MINUTES\n        )\n            .setConstraints(LogSyncConstraints)\n            .setBackoffCriteria(\n                BackoffPolicy.LINEAR,\n                MIN_BACKOFF_MILLIS,\n                TimeUnit.MILLISECONDS\n            )\n            .setInputData(\n                Data.Builder()\n                    .putString(\"externalFilesDirPath\", externalFilesDirPath?.absolutePath)\n                    .build()\n            )\n            .build()\n    }\n}\n```\n\n간단하게 위 스니펫의 로직을 설명하면, 먼저 로그 파일 디렉터리 경로를 기반으로 파일 객체를 생성하고, **2주** 이내에 수정된 파일들을 필터링하며, 최근 수정된 순서로 정렬한 뒤, 예외가 발생했을 때에는 `선형 재시도` 정책을 따르도록 설정해주었고, 각 파일에 대해 `빌드타입`에 따른 정보와, 파일의 수정 날짜, 파일 이름의 인덱스를 조합하여 AWS S3에 저장할 키를 구성하고, 이후 파일을 업로드하고 그 결과를 Timber 로그로 남기는 흐름입니다. 이 작업은 `주기적으로 실행되는 작업`에 해당하므로 [Workmanager](https://developer.android.com/topic/libraries/architecture/workmanager?hl=ko)의 [PeriodicWorkRequest.Builder](https://developer.android.com/reference/androidx/work/PeriodicWorkRequest.Builder)를 활용하였습니다.\n\n![](aws-amplify-issue-comment.png)\n\n이후 해당 이슈란의 코멘트를 통해 메인테이너분들과 이슈의 발생 빈도와 문제 발생 기기의 스펙 정보들을 요청받았고, 당시에는 [aws-amplify/amplify-android](https://github.com/aws-amplify/amplify-android) 라이브러리 자체의 문제라기보다는 `내가 구현한 코드에 문제가 있었나?`, `OOM이 발생하지 않도록 더 최적화 할수는 없는가?`라고 고민을 하였고, 이를 해결하기 위해 아래의 개선작업들을 진행했습니다.\n\n- 로그 파일 리스트를 즉시 모두 메모리에 로드하지 않고, 필요한 시점에만 File 객체를 생성하도록 개선하기\n- 14일 이상된 오래된 로그 파일들을 주기적으로 삭제하여 처리해야할 로그 파일 수 자체를 줄이기\n\n하지만, 이러한 노력에도 불구하고 여전히 주기적으로 OOM 오류들이 수집되었습니다.\n\n### 직접 수정해보자\n오픈소스와 관련된 활동을 한다면, 라이선스 규정을 잘 준수해야 합니다. 또한 오픈소스 프로젝트에 컨트리뷰션을 하기 전에는 `CONTRIBUTING.md` 파일을 꼼꼼하게 읽어 가이드라인을 잘 준수할 수 있도록 해야합니다.\n\n저는 직접 수정해보기로 마음먹었습니다. 수집된 크래시 리포트를 다시 분석하여 코드를 수정한 뒤 PR을 생성하였고, 수정된 코드는 아래와 같습니다.\n\n```kotlin\nimport java.util.concurrent.ConcurrentHashMap\n\nprivate val observedTags = ConcurrentHashMap.newKeySet<String>()\n\nprivate suspend fun attachObserver(tag: String) {\n    withContext(Dispatchers.Main) {\n        if (!observedTags.add(tag)) return@withContext\n        val liveData = workManager.getWorkInfosByTagLiveData(tag)\n        liveData.observeForever(this@TransferWorkerObserver)\n    }\n}\n\nprivate suspend fun removeObserver(tag: String) {\n    withContext(Dispatchers.Main) {\n        if (!observedTags.remove(tag)) return@withContext\n        workManager.getWorkInfosByTagLiveData(tag)\n            .removeObserver(this@TransferWorkerObserver)\n    }\n}\n```\n\nAWS Amplify Storage 모듈의 [TransferWorkerObserver](https://github.com/aws-amplify/amplify-android/blob/main/aws-storage-s3/src/main/java/com/amplifyframework/storage/s3/transfer/TransferWorkerObserver.kt) 클래스에 중복 관찰자 등록을 방지하는 로직을 추가하였고, [ConcurrentHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html)은 `thread-safe`하며, `ConcurrentHashMap.newKeySet()`은 `Set` 인터페이스를 제공해주는데, 태그가 이미 존재하면 `add()`는 `false`를 반환하고, 얼리 리턴을 통해 함수를 종료합니다. 마찬가지로 `remove()`는 태그가 `observedTags`에 없으면 false를 반환하고 함수를 종료시킵니다. 이를 통해 불필요한 중복된 태그 등록을 방지할 수 있도록 수정하였습니다.\n\n### 뿌듯한 결과\n![](aws-amplify-approve-comment.png)\n\n메인테이너분으로부터 좋은 아이디어라는 의견과 함께 몇 가지 제안사항들을 수정한 뒤에 최종 승인이 되었고, [2.27.1](https://github.com/aws-amplify/amplify-android/releases/tag/release_v2.27.1) 버전에 해당 작업이 반영되어 릴리즈 되었습니다 🎉 \n\n이러한 경험을 통해서 회사 프로젝트에서 사용중인 오픈소스 라이브러리 오류를 발견하면 적극적으로 PR을 올려 기여하고 문제를 수정하는 것이 중요하다고 느꼈고, 자주 사용했지만 몰랐던 라이브러리의 내부 동작을 살펴보는 경험을 하게 되었습니다.\n\n### 아쉬웠던 점, 그리고 반성\n\n> 만약 Heap Dump를 더욱 끈질기게 분석했더라면, 문제의 근본 원인을 더 빠르게 파악하고 보다 더 근거있는 이슈 트래킹에 큰 도움이 되었지 않았을까?"},{"excerpt":"안드로이드 개발자라면 Dalvik, ART에 대해서 많이 들어봤을 것입니다. Dalvik은 초기 안드로이드에서 사용된 가상 머신으로, 메모리와 배터리 제약을 극복하기 위해 스택 기반 대신 레지스터 기반 바이트코드를 사용하여 효율적으로 동작하도록 설계되었습니다. 이후 Android 5.0부터는 가 기본 런타임 환경으로 전환되었는데, ART는 설치 시 를 통…","fields":{"slug":"/jvm-under-the-hood/"},"frontmatter":{"date":"August 21, 2024","title":"책 『JVM 밑바닥까지 파헤치기』 후기","tags":["book"]},"rawMarkdownBody":"\n안드로이드 개발자라면 **Dalvik, ART**에 대해서 많이 들어봤을 것입니다. [Dalvik](https://en.wikipedia.org/wiki/Dalvik_(software))은 초기 안드로이드에서 사용된 가상 머신으로, 메모리와 배터리 제약을 극복하기 위해 스택 기반 대신 레지스터 기반 바이트코드를 사용하여 효율적으로 동작하도록 설계되었습니다. 이후 Android 5.0부터는 `ART(Android Runtime)`가 기본 런타임 환경으로 전환되었는데, ART는 설치 시 `AOT(Ahead-Of-Time)`를 통해 앱을 네이티브 코드로 변환하고, 필요에 따라 `JIT(Just-In-Time)`를 추가로 적용하여 실행 성능을 크게 향상시킵니다.\n\n마침 회사 백엔드 개발자분들께서도 JVM에 관심이 생겨 사내에서 함께 공부해 보자는 제안을 해주셨고, 평소 더 파보고 싶었던 JVM의 `GC`, `메모리 관리 기법` 등의 개념을 공부하면 Android 런타임 환경의 내부 동작 방식을 이해하는 데에 도움이 될 수 있을 것이라고 생각하여 설레는 마음으로 스터디에 합류하게 되었습니다.\n\n![책이 생각보다 훨씬 두꺼워서 놀랐었다...](jvm-under-the-hood.png)\n\n스터디 교재로는 [『JVM 밑바닥까지 파헤치기』](https://www.yes24.com/Product/Goods/126114513)라는 책을 선택했습니다. 책의 분량이 많았기 때문에 챕터별로 담당자를 지정해서 읽어오고, 이를 사내 컨플루언스에 문서화하고 발표하는 방식의 스터디를 진행하였습니다. 발표를 하면서도 짧은 질문과 의견들이 오고갔고, 주로 `이 부분에서 자신이 이해한 것이 맞는지?`를 중심으로 근거를 찾아가면서 스터디를 진행하였습니다.\n\n> 여러 챕터에 걸쳐서 안드로이드 개발자에게 좋은 내용들이 많았지만, 개인적으로는 가비지 컬렉터의 내용이 가장 좋았기 때문에 '3장 가비지 컬렉터와 메모리 할당 전략'의 핵심 내용들을 요약해서 정리해보도록 하겠습니다.\n\n### 가비지 컬렉션?\n가비지 컬렉션(GC)은 자바 언어에서 처음 소개한 기술이 아니며, MIT에서 개발된 리스프라는 언어가 시초라고 합니다. 이러한 가비지 컬렉션과 메모리 할당의 내부 동작을 이해하면 다양한 메모리 오버플로우, 메모리 누수 문제를 해결해야하는 상황에 도움이 될 수 있습니다. \n\n### 자바 힙과 메서드 영역은 불확실\n구현한 클래스마다 요구하는 메모리 크기가 다를 수 있습니다. 프로그램이 어떤 객체를 생성할지, 얼마나 많이 만들지는 오직 런타임에만 알 수 있습니다. 그래서 이 메모리 영역들의 회수는 동적으로 이루어지고, 가비지 컬렉터는 이런 영역을 관리하는 데 집중합니다.\n\n가비지 컬렉터가 **힙을 청소**하려면 어떤 객체가 살아 있고 죽었는지를 판단해야 하는데, 여기서 죽었다는 말은 어떤 식으로도 프로그램 코드에서 사용될 수 없다는 뜻입니다.\n\n여기서 객체가 살아있는지 판단하는 알고리즘으로 크게 두 가지로 나눌 수 있습니다.\n\n- 참조 카운팅 알고리즘\n- 도달 가능성 분석 알고리즘\n\n### 참조 카운팅 알고리즘\n1. 객체를 가리키는 참조 카운터를 추가. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가\n2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소\n3. 카운터 값이 0이 된 객체는 더는 사용될 수 없음\n\n> 마이크로소프트 COM, 파이썬, 러스트 등이 메모리 관리에 참조 카운팅 알고리즘 사용한다고 합니다.\n\n그런데 자바, 적어도 자바 가상 머신에서는 참조 카운팅을 사용하지 않는데, 그 이유는 바로 `순환 참조 문제`를 풀기 어렵기 때문입니다.\n\n```java\npublic class ReferenceCountingGC {\n  public Object instance = null;\n  // ...\n  public static void testGC() {\n    // 두 객체 생성\n    ReferenceCountingGC objA = new ReferenceCountingGC();\n    ReferenceCountingGC objB = new ReferenceCountingGC();\n    // 내부 필드로 서로를 참조\n    objA.instance = objB;\n    objB.instance = objA;\n    // 참조 해제\n    objA = null;\n    objB = null;\n    // 이 라인에서 GC가 수행된다면 objA와 objB가 회수될까?\n    System.gc();\n  }\n  public static void main(String[] args) {\n    testGC();\n  }\n}\n```\n\n참조를 해제한 시점부터 두 객체에 접근할 길이 사라지지만, 아직도 서로를 참조하고 있기 때문에 참조 카운터는 아직 0이 아닙니다. 따라서 참조 카운팅 알고리즘으로는 둘을 회수하지 못하게 됩니다.\n\n그러나 실행 결과 자바 가상머신에서 `objA`와 `objB`가 메모리에서 회수되었음을 확인할 수 있고, 이는 자바 가상 머신은 객체 생사 판단에 `참조 카운팅 알고리즘`을 사용하지 않는다는 것을 알 수 있습니다.\n\n### 도달 가능성 분석 알고리즘\n자바, C# 등의 주류 언어들은 객체 생사 판단에 도달 가능성 분석(reachability analysis) 알고리즘을 사용합니다. 이 알고리즘의 핵심은 `GC 루트` 입니다. 이 루트 객체들을 시작 노드 집합으로 사용하며, 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색하여 들어가는 흐름으로 진행됩니다. 이때 탐색 과정에서 만들어지는 경로를 `참조 체인(reference chain)`이라고 부릅니다.\n\n![](gc-root.png)\n\n단, 자바에서 GC 루트로 이용할 수 있는 객체는 정해져 있는데, 그 종류는 다음과 같습니다.\n\n- `가상 머신 스택(스택 프레임의 지역 변수 테이블)에서 참조하는 객체` : 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등\n- `메서드 영역에서 클래스가 정적 필드로 참조하는 객체` : 자바 클래스의 참조 타입 정적 변수\n- `메서드 영역에서 상수로 참조되는 객체` : 문자열 테이블 안의 참조\n- `네이티브 메서드 스택에서 JNI가 참조하는 객체`\n- `자바 가상 머신 내부에서 쓰이는 참조` : 기본 데이터 타입에 해당하는 Class 객체, 시스템 클래스 로더 등\n- `동기화 락(synchronized 키워드)으로 잠겨 있는 모든 객체`\n- `자바 가상 머신 내부 상황을 반영하는 JMXBean` : JVMTI에 등록된 콜백, 로컬 코드 캐시 등\n\n이외에도 가비지 컬렉터의 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 `임시로` 추가가 가능합니다.\n\n### 세대 단위 컬렉션 이론\n현재 상용 가상 머신들이 채택한 가비지 컬렉터들은 대부분 세대 단위 컬렉션 이론에 기초해 설계되었습니다.\n\n<span style=\"color:orange\">1. 약한 세대 가설 : 대다수 객체는 일찍 죽는다.</span>\n\n<span style=\"color:orange\">2. 강한 세대 가설 : 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.</span>\n\n> 💬 “늙었다는 것은 살아남았다는 것”\n\n이 두 가지 가정이 합쳐져 가비지 컬렉터들에 일관된 설계 원칙을 제공합니다.\n여기서 `나이 = 가비지 컬렉션에서 살아남은 횟수`이고, **대부분의 객체가 곧바로 죽을 운명이라면?** 살아남는 소수의 객체를 유지하는 방법에 집중하는 편이 유리합니다.\n한 번 살아남은 객체는 통계적으로 잘 죽지 않으니 다른 영역에 따로 모아 두고, 가상 머신이 그 영역을 회수하는 빈도를 줄이는 방식입니다.\n\n이러한 세대 단위 컬렉션 이론을 가상 머신에 적용한 설계자들은 **자바 힙**을 최소 두개의 영역으로 나누게 되었습니다.\n\n- 신세대 : 가비지 컬렉션 때마다 다수의 객체가 죽고 살아남은 소수만 구세대로 승격\n- 구세대 \n\n그러나 복잡해 보이는 상황이 하나가 있습니다. 🤔\n\n- 객체들은 단독으로 존재 X\n- 다른 세대에 존재하는 객체들을 참조하는 상황이 있음\n\n또한, 신세대에서만 가비지 컬렉션을 하고 싶어도 구세대에서 참조 중인 객체도 분명 있을 것입니다. 살아남을 객체를 찾으려면 고정된 `GC 루트`들뿐 아니라 `구세대 객체까지` 모두 탐색해야 하며, 이 경우 성능 면에서 확실히 부담이 큽니다. 이 문제를 풀기 위해 `세대 단위 컬렉션 이론`에 **3번째** 가정이 추가됩니다.\n\n<span style=\"color:orange\">3. 세대 간 참조 가설 : 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.</span>\n\n상호 참조 관계의 두 객체는 `삶과 죽음을 함께하는 경향`이 있습니다. 신세대 객체가 세대 간 참조를 가지고 있을 때 구세대 객체는 잘 죽지 않기 때문에 가비지 컬렉션을 거쳐도 신세대 객체는 세대 간 참조 덕에 구세대로 승격됩니다. 이렇게 같은 세대가 되었으므로 세대 간 참조는 자연스럽게 사라게 됩니다.\n\n따라서 이 가설에 따르면 세대 간 참조의 수는 아주 적기 때문에 구세대 전체를 훑는 건 시간 낭비라고 판단합니다.\n\n\n### 마크-스윕 알고리즘\n![](mark-sweep-algorithm.png)\n가장 기본적인 가비지 컬렉션 알고리즘입니다. 먼저 회수할 객체들에 모두 표시(mark)한 다음, 표시된 객체들을 쓸어 담는(sweep) 방식입니다. 반대로, 살릴 객체에 표시(mark)하고, 표시되지 않은 객체를 회수(sweep) 하기도 합니다.\n\n#### 단점은?\n- 실행 효율이 일정하지 않음 : 자바 힙이 다량의 객체로 가득 차 있고 대부분이 회수 대상이라면? 표시하는 일 & 회수하는 일 모두 커짐 → 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어짐\n\n- 메모리 파편화가 심함 : 가비지 컬렉터가 쓸고 간 자리에는 불연속적인 메모리 파편이 만들어짐. → 파편화가 너무 심하면 프로그램이 큰 객체를 만들려 할 때 충분한 크기의 연속된 메모리를 찾기가 점점 어려워짐 → 또 다른 가비지 컬렉션 유발\n\n### 마크-카피 알고리즘\n![](mark-copy-algorithm.png)\n회수할 객체가 많아질수록 효율이 떨어지는 마크-스윕 알고리즘의 문제를 해결하기 위해 생겨나게 되었습니다. 가용 메모리를 똑같은 크기의 두 블록으로 나눠서 한 번에 한 블록만 사용하고, 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록 목록을 한 번에 청소하는 방식입니다.\n\n만약 대다수 객체가 살아남으면? 메모리 복사에 상당한 시간 허비를 하게 됩니다.\n대다수 객체가 회수된다면? 생존한 소수의 객체만 복사하면 됨 & 복사 과정에서 객체들이 메모리 한쪽 끝에서 차곡차곡 쌓이기 때문에 메모리 파편화 문제로부터 해방됩니다.\n\n### 단점은?\n가용 메모리를 절반으로 줄여 낭비가 제법 심하다는 점\n\n오늘날 상용 자바 가상 머신은 대부분 신세대에 이 알고리즘을 적용합니다.\nIBM의 연구에 따르면 신세대 객체 중 `98`%가 첫 번째 가비지 컬렉션에 살아남지 못했고, 이는 신세대용 메모리 영역을 1:1로 나눌 필요가 없다는 결론이 나게 됩니다.\n\n![](young-gen-and-old-gen.png)\n신세대를 하나의 큰 에덴 공간(80%)과 두 개의 작은 생존자 공간(10%)으로 나누는데, 핫스팟 가상 머신에서 에덴과 생존자 공간의 비율은 기본적으로 8:1 (에덴 80% + 생존자 공간 중 하나 10%) 입니다. (낭비하는 공간은 단 10%뿐)\n\n- 98%의 객체가 회수된다는 데이터 = ‘일반적인 상황'에서 측정된 결과\n> 😮 10% 넘는 객체가 살아남는 특이 케이스는 어쩌고? \n\n이런 케이스에 대처하기 위한 설계로 `메모리 할당 보증 메커니즘` 개념이 등장합니다.\n\n### 메모리 할당 보증 메커니즘\n마이너 GC(신세대 GC)에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역(구세대)를 활용해 메모리 할당을 보증하는 것으로, 이러한 할당 보증 메커니즘을 통해 가비지 컬렉션에서 살아남은 객체를 구세대에 바로 추가합니다.\n\n### 마크-컴팩트 알고리즘\n`마크-카피 알고리즘`은 객체 생존율이 높을수록 복사할 게 많아져서 효율이 나빠집니다. 공간을 50%나 낭비하기 싫다면 할당 보증용 공간을 따로 마련하여 대다수 객체가 살아남는 극단적 상황에 대처해야 하기 때문에 구세대에는 적합하지 않습니다. (객체 생존율이 높기 때문)\n\n![](mark-compact-algorithm.png)\n이는 마크-컴팩트 알고리즘인데, 표시 단계는 `마크-스윕`과 같습니다. 회수 대상 객체들을 모두 쓸어 담는 대신 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비웁니다. \n\n#### 마크-스윕 알고리즘과의 차이는?\n> 💬 메모리 이동이 일어난다는 점\n\n그런데? 가비지 컬렉션 후 살아남은 객체를 이동할지는 양날의 검과 같은 결정입니다. 구세대에서는 회수 때마다 살아남는 객체가 상당히 많을텐데, 생존한 객체들을 이동시킨 후, 이동된 객체들을 가리키던 기존 참조를 모두 갱신하는 것은 매우 부담되고, 그렇다고 `마크-스윕 알고리즘`처럼 살아있는 객체를 전혀 이동시키지 않는다면 힙이 파편화되는 문제가 발생합니다. 그러나 이러한 문제는 \n<span style=\"color:yellowgreen\">파편화 없는 할당 연결 리스트로 해결 가능</span>합니다.\n\n하드디스크나 SSD에는 물리적으로 연속된 공간이 없더라도 큰 파일을 저장할 수 있는 이유가 파일을 조각으로 나눠 물리적으로 떨어진 파티션에 저장한 다음 이를 파티션 테이블로 관리하기 때문입니다.\n\n대부분의 경우 메모리 파편화를 감내하면서 `마크-스윕`을 사용하다가, 객체 할당에 영향을 줄 만큼 파편화가 심해지면 `마크-컴팩트`를 돌려 연속된 공간을 확보하는 해법도 있습니다.\n\n### 회고 및 마무리\n\n책의 내용이 방대하였기에, 회사 동료분들과 함께 각 챕터별로 담당자를 맡아서 핵심 개념을 요약하여 공유하는 방식을 통해 효율적으로 스터디할 수 있었던 것 같습니다. 또한 `JVM`을 공부하면 공부할수록 이 분야는 논문을 준비하는 대학원 석사 연구생들이 연구해봐도 좋을 것 같다라고 느낄정도로 심오하고도 깊은 내용이 많았습니다. 안드로이드 개발을 하다보면, 필요에 따라 빌드 구성 시 `JVM` 옵션을 설정할 때도 있는데, 이와 관련해서도 그동안 몰랐던 옵션들도 새롭게 알게 되었습니다. 업무를 하면서 `JVM, GC`와 관련하여 더 공부해보고 싶을 때, 이 책을 자주 찾을 것 같습니다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}